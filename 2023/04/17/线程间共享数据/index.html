<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>线程间共享数据 - MK&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="MK&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="MK&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content=""><meta property="og:type" content="blog"><meta property="og:title" content="线程间共享数据"><meta property="og:url" content="http://mkmq99.github.io/2023/04/17/%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/"><meta property="og:site_name" content="MK&#039;s Blog"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://mkmq99.github.io/2023/04/17/%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/0.png"><meta property="article:published_time" content="2023-04-17T07:48:55.000Z"><meta property="article:modified_time" content="2023-04-18T03:21:47.015Z"><meta property="article:author" content="MK"><meta property="article:tag" content="C++"><meta property="article:tag" content="多线程"><meta property="article:tag" content="并发"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://mkmq99.github.io/2023/04/17/%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/0.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://mkmq99.github.io/2023/04/17/%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/"},"headline":"线程间共享数据","image":["http://mkmq99.github.io/2023/04/17/%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/0.png"],"datePublished":"2023-04-17T07:48:55.000Z","dateModified":"2023-04-18T03:21:47.015Z","author":{"@type":"Person","name":"MK"},"publisher":{"@type":"Organization","name":"MK's Blog","logo":{"@type":"ImageObject","url":{"text":"MK's Blog"}}},"description":""}</script><link rel="canonical" href="http://mkmq99.github.io/2023/04/17/%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">MK&#039;s Blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-04-17T07:48:55.000Z" title="2023/4/17 15:48:55">2023-04-17</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-04-18T03:21:47.015Z" title="2023/4/18 11:21:47">2023-04-18</time></span><span class="level-item"><a class="link-muted" href="/categories/C/">C++</a></span><span class="level-item">21 minutes read (About 3170 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">线程间共享数据</h1><div class="content"><p><img src="/2023/04/17/%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/0.png"></p>
<span id="more"></span>

<h3 id="1-使用互斥量保护共享数据"><a href="#1-使用互斥量保护共享数据" class="headerlink" title="1 使用互斥量保护共享数据"></a>1 使用互斥量保护共享数据</h3><p>互斥量是C++中一种最通用的数据保护机制，但是依旧需要精心组织代码，否则会造成死锁。</p>
<h4 id="1-1-C-中使用互斥量"><a href="#1-1-C-中使用互斥量" class="headerlink" title="1.1 C++中使用互斥量"></a>1.1 C++中使用互斥量</h4><p>C++中通过实例化<code>std::mutex</code>创建互斥量，通过调用成员函数lock()进行上锁，unlock()进行解锁。在实践中，C++标准库为互斥量提供了一个RAII语法的模板类<code>std::lock_guard</code>，其会在构造的时候提供已锁的互斥量，并在析构的时候进行解锁，从而保证了一个已锁的互斥量总是会被正确的解锁。</p>
<p>但是，当其中一个成员函数返回的是保护数据的指针或引用时，会破坏对数据的保护。<strong>具有访问能力的指针或引用可以访问(并可能修改)被保护的数据，而不会被互斥锁限制</strong>。互斥量保护的数据需要对接口的设计相当谨慎，要确保互斥量能锁住任何对保护数据的访问，并且不留后门。</p>
<h4 id="1-2-死锁一般解决方案"><a href="#1-2-死锁一般解决方案" class="headerlink" title="1.2 死锁一般解决方案"></a>1.2 死锁一般解决方案</h4><p>避免死锁的一般建议，就是让两个互斥量总以相同的顺序上锁：总在互斥量B之前锁住互斥量A，就永远不会死锁。某些情况下是可以这样用，因为不同的互斥量用于不同的地方。不过，事情没那么简单，比如：当有多个互斥量保护同一个类的独立实例时，一个操作对同一个类的两个不同实例进行数据的交换操作，为了保证数据交换操作的正确性，就要避免数据被并发修改，并确保每个实例上的互斥量都能锁住自己要保护的区域。不过，选择一个固定的顺序(例如，实例提供的第一互斥量作为第一个参数，提供的第二个互斥量为第二个参数)，可能会适得其反：<strong>在参数交换了之后</strong>，两个线程试图在相同的两个实例间进行数据交换时，程序又死锁了！</p>
<p>C++标准库有办法解决这个问题，<code>std::lock</code>——可以一次性锁住多个(两个以上)的互斥量，并且没有副作用(死锁风险)。下面的程序清单展示了怎么在一个简单的交换操作中使用<code>std::lock</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		some_big_object some_detail;</span><br><span class="line">    	std::mutex m;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(X&amp; lhs, X&amp; rhs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(&amp;lhs==&amp;rhs) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// adopt_lock 要求调用线程当前拥有锁</span></span><br><span class="line">        std::<span class="built_in">lock</span>(lhs.m, rhs.m);</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(lhs.m, std::adopt_lock)</span></span>;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(rhs.m, std::adopt_lock)</span></span>;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 等价方法：</span></span><br><span class="line">        <span class="comment">// std::unique_lock&lt;std::mutex&gt; lock1(lhs.m, std::defer_lock);</span></span><br><span class="line">        <span class="comment">// std::unique_lock&lt;std::mutex&gt; lock2(rhs.m, std::defer_lock);</span></span><br><span class="line">        <span class="comment">// std::lock(lock1, lock2);</span></span><br><span class="line">         </span><br><span class="line">        <span class="built_in">swap</span>(lhs.some_detail,rhs.some_detail);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-原子类型与原子操作"><a href="#2-原子类型与原子操作" class="headerlink" title="2 原子类型与原子操作"></a>2 原子类型与原子操作</h3><h4 id="2-1-原子类型与原子操作"><a href="#2-1-原子类型与原子操作" class="headerlink" title="2.1 原子类型与原子操作"></a>2.1 原子类型与原子操作</h4><p>C++11通过引入原子类型帮助开发者轻松实现原子操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">atomic_int64_t</span> total = <span class="number">0</span>;       <span class="comment">//atomic_int64_t相当于int64_t，但是本身就拥有原子性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程函数，用于累加</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunc</span><span class="params">(<span class="type">int64_t</span> endNum)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int64_t</span> i = <span class="number">1</span>; i &lt;= endNum; ++i)&#123;</span><br><span class="line">		total += i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int64_t</span> endNum = <span class="number">100</span>;</span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(threadFunc, endNum)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">t2</span><span class="params">(threadFunc, endNum)</span></span>;</span><br><span class="line"></span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;total=&quot;</span> &lt;&lt; total &lt;&lt; endl;    <span class="comment">//10100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原子类型C++11中通过<code>atomic&lt;T&gt;</code>类模板来定义，比如atomic_int64_t是通过<code>typedef atomic&lt;int64_t&gt; atomic_int64_t</code>实现的，使用时需包含头文件<code>&lt;atomic&gt;</code>。除了提供atomic_int64_t，还提供了其它的原子类型。常见的原子类型有：</p>
<table>
<thead>
<tr>
<th align="center">原子类型名称</th>
<th align="center">对应内置类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">atomic_bool</td>
<td align="center">bool</td>
</tr>
<tr>
<td align="center">atomic_char</td>
<td align="center">atomic_char</td>
</tr>
<tr>
<td align="center">atomic_char</td>
<td align="center">signed char</td>
</tr>
<tr>
<td align="center">atomic_uchar</td>
<td align="center">unsigned char</td>
</tr>
<tr>
<td align="center">atomic_short</td>
<td align="center">short</td>
</tr>
<tr>
<td align="center">atomic_ushort</td>
<td align="center">unsigned short</td>
</tr>
<tr>
<td align="center">atomic_int</td>
<td align="center">int</td>
</tr>
<tr>
<td align="center">atomic_uint</td>
<td align="center">unsigned int</td>
</tr>
<tr>
<td align="center">atomic_long</td>
<td align="center">long</td>
</tr>
<tr>
<td align="center">atomic_ulong</td>
<td align="center">unsigned long</td>
</tr>
<tr>
<td align="center">atomic_llong</td>
<td align="center">long long</td>
</tr>
<tr>
<td align="center">atomic_ullong</td>
<td align="center">unsigned long long</td>
</tr>
<tr>
<td align="center">atomic_ullong</td>
<td align="center">unsigned long long</td>
</tr>
<tr>
<td align="center">atomic_char16_t</td>
<td align="center">char16_t</td>
</tr>
<tr>
<td align="center">atomic_char32_t</td>
<td align="center">char32_t</td>
</tr>
<tr>
<td align="center">atomic_wchar_t</td>
<td align="center">wchar_t</td>
</tr>
</tbody></table>
<p>原子操作是平台相关的，原子类型能够实现原子操作是因为C++11对原子类型的操作进行了抽象，定义了统一的接口，并要求编译器产生平台相关的原子操作的具体实现。C++11标准将原子操作定义为atomic模板类的成员函数，包括读（load）、写（store）、交换（exchange）等。对于内置类型而言，主要是通过重载一些全局操作符来完成的。比如对上文<code>total+=i</code>的原子加操作，是通过对operator+&#x3D;重载来实现的。使用g++编译的话，在x86_64的机器上，operator+&#x3D;()函数会产生一条特殊的以lock为前缀的x86_64指令，用于控制总线及实现x86_64平台上的原子性加法。</p>
<p>另外，列表中有一个比较特殊的atomic_flag类型，atomic_flag与其他类型不同，它是无锁(lock_free)的，而其他的类型不一定是无锁的。因为，atomic&lt;T&gt;并不能保证类型T是无锁的，另外不同平台的处理器处理方式不同，也不能保证必定无锁，所以其他的类型都会有is_lock_free来判断是否是无锁的。atomic_flag只支持test_and_set以及clear两个成员函数，test_and_set函数检查 std::atomic_flag 标志，如果 std::atomic_flag 之前没有被设置过，则设置 std::atomic_flag 的标志，并返回先前该 std::atomic_flag 对象是否被设置过，如果之前 std::atomic_flag 对象已被设置，则返回 true，否则返回 false；clear函数清除 std::atomic_flag 标志使得下一次调用 std::atomic_flag::test_and_set 返回 false。可以用这两个函数来实现一个自旋锁：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic_flag lock = ATOMIC_FLAG_INIT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (lock.<span class="built_in">test_and_set</span>(std::memory_order_acquire))    <span class="comment">// 在主线程中设置为true，需要等待t2线程clear</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;func1 wait&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;func1 do something&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;func2 start&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    lock.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    lock.<span class="built_in">test_and_set</span>();	<span class="comment">// 设置状态</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(func1)</span></span>;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);				<span class="comment">//睡眠1us</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(func2)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码中，线程t1调用test_and_set一直返回true(因为在主线程中被设置过)，所以一直在等待，而等待一段时间后当线程t2运行并调用了clear，test_and_set返回了false退出循环等待并进行相应操作。这样一来，就实现了一个线程等待另一个线程的效果。当然，可以封装成锁操作的方式，比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Lock</span><span class="params">(atomic_flag&amp; lock)</span></span>&#123; <span class="keyword">while</span> ( lock.<span class="built_in">test_and_set</span>()); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UnLock</span><span class="params">(atomic_flag&amp; lock)</span></span>&#123; lock.<span class="built_in">clear</span>(); &#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，就可以通过Lock()和UnLock()的方式来互斥地访问临界区。</p>
<h4 id="2-2-内存模型、顺序一致性和memory-order"><a href="#2-2-内存模型、顺序一致性和memory-order" class="headerlink" title="2.2 内存模型、顺序一致性和memory_order"></a>2.2 内存模型、顺序一致性和memory_order</h4><p>内存模型是一个硬件上的概念,表示机器指令是以什么样的顺序被处理器执行的 (现代的处理器不是逐条处理机器指令的) 。C++11中顺序一致性只是多种内存模型中的一种，代码并非必须按照顺序执行，因为顺序往往意味着最低效的同步方式，现代的处理器并不是逐条处理机器指令的。高级语言和机器指令是通过编译器来进行转换的，而编译器处于代码优化的考虑，会将指令进行移动。对于C++11的内存模型而言，要保证代码的顺序一致性，需要同时做到以下几点：</p>
<ul>
<li>编译器保证原子操作的指令间顺序不变，即产生的读写原子类型变量的机器指令和代码编写顺序是一样的。</li>
<li>处理器对原子操作的汇编指令的执行顺序不变。这对于x86这样的强顺序的体系结构而言没有任何问题，而对于一些弱顺序的平台则需要原子操作之后要加入内存栅栏。</li>
</ul>
<p>对于一些代码来说，如果只需要在主线程中打印结果，那么代码的执行顺序并不重要。但是atomic原子类型默认的顺序一致性会要求编译器禁用优化，这无疑增加了性能开销。于是C++11中，设计了能够对原子类型指定内存顺序memory_order。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改进代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a.<span class="built_in">store</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line">    b.<span class="built_in">store</span>(<span class="number">2</span>, std::memory_order_relaxed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码使用了store函数进行赋值，store函数接受两个参数，第一个是要写入的值，第二个是名为memory_order的枚举值。这里使用了std::memory_order_relaxed，表示松散内存顺序，该枚举值代表编译器可以任由编译器重新排序或则由处理器乱序处理。这样a和b的赋值执行顺序性就被解除了。在C++11中一共有6种memory_order枚举值，默认按照memory_order_seq_cst执行：</p>
<table>
<thead>
<tr>
<th align="center">枚举值</th>
<th align="center">定义规则</th>
</tr>
</thead>
<tbody><tr>
<td align="center">memory_order_relaxed</td>
<td align="center">不对执行顺序做保证</td>
</tr>
<tr>
<td align="center">memory_order_acquire</td>
<td align="center">本线程中,所有后续的读操作必须在本条原子操作完成后执行</td>
</tr>
<tr>
<td align="center">memory_order_release</td>
<td align="center">本线程中,所有之前的写操作完成后才能执行本条原子操作</td>
</tr>
<tr>
<td align="center">memory_order_acq_rel</td>
<td align="center">同时包含memory_order_acquire和memory_order_release</td>
</tr>
<tr>
<td align="center">memory_order_consume</td>
<td align="center">本线程中,所有后续的有关本原子类型的操作,必须在本条原子操作完成之后执行</td>
</tr>
<tr>
<td align="center">memory_order_seq_cst</td>
<td align="center">全部存取都按顺序执行</td>
</tr>
</tbody></table>
<p>需要注意的是，不是所有的memory_order都能被atomic成员使用：</p>
<ul>
<li>store函数可以使用memory_order_seq_cst、memory_order_release、memory_order_relaxed。</li>
<li>load函数可以使用memory_order_seq_cst、memory_order_acquire、memory_order_consume、memory_order_relaxed。</li>
<li>需要同时读写的操作，例如test_and_flag、exchange等操作。可以使用memory_order_seq_cst、memory_order_rel、memory_order_release、memory_order_acquire、memory_order_consume、memory_order_relaxed。</li>
</ul>
<p>原子类型提供的一些操作符都是memory_order_seq_cst的封装，所以他们都是顺序一致性的。</p>
<p>最后说明一下，std::atomic和std::memory_order只有在多cpu多线程情况下，无锁编程才会用到。在x86下，由于是strong memory order的，所以很多时候只需要考虑编译器优化；保险起见，可以用std::atomic，他会同时处理编译器优化和cpu的memory order（虽然x86用不到）。但是在除非必要的情况下，不用使用std::memory_order，std::atmoic默认用的是最强限制。</p>
<h4 id="2-3-内存栅栏"><a href="#2-3-内存栅栏" class="headerlink" title="2.3 内存栅栏"></a>2.3 内存栅栏</h4><p>C++中提供了两种栅栏，内存栅栏（atomic_thread_fence）用于解决线程之间表现的内存乱序，其阻止CPU指令层面的乱序优化；编译栅栏（atomic_signal_fence）用于解决与信号处理程序（一种软中断程序）之间表现的内存乱序，其仅阻止编译器层面的乱序优化，不产生内存屏障指令。（内存屏障是一类同步屏障指令，是CPU或者编译器在对内存随机访问的操作中的一个同步点，只有在此点之前的所有读写操作都执行后才可以执行此点之后的操作。）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++内存栅栏的函数定义：</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">atomic_thread_fence</span><span class="params">(std::memory_order order)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">//C++编译栅栏的函数定义：</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">atomic_signal_fence</span><span class="params">(std::memory_order order)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.bookstack.cn/books/Cpp_Concurrency_In_Action">C++并发编程(中文版)（C++ Concurrency In Action）</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1380964">C++11原子类型与原子操作 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/WizardtoH/article/details/81111549">(56条消息) 《深入理解C++11》笔记-原子类型和原子操作_WizardtoH的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_25675517/article/details/120391065">(56条消息) 处理器协同机制其三C++内存顺序与栅栏（及依赖性读屏障）_c++ 栅栏_一念之卓的博客-CSDN博客</a></p>
</blockquote>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/C/">C++</a><a class="link-muted mr-2" rel="tag" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a><a class="link-muted mr-2" rel="tag" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2023/04/18/%E5%9F%BA%E4%BA%8E%E9%94%81%E7%9A%84%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">基于锁的并发数据结构(C++)</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2023/04/14/%E5%89%96%E6%9E%90HTTPS/"><span class="level-item">剖析HTTPS</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="MK"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">MK</p><p class="is-size-6 is-block">MKMQ99</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shanghai</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">9</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">6</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">16</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/MKMQ99" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/MKMQ99"><i class="fab fa-github"></i></a></div></div></div><div class="card widget is-sticky" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#1-使用互斥量保护共享数据"><span class="level-left"><span class="level-item">1</span><span class="level-item">1 使用互斥量保护共享数据</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-1-C-中使用互斥量"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">1.1 C++中使用互斥量</span></span></a></li><li><a class="level is-mobile" href="#1-2-死锁一般解决方案"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">1.2 死锁一般解决方案</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-原子类型与原子操作"><span class="level-left"><span class="level-item">2</span><span class="level-item">2 原子类型与原子操作</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-原子类型与原子操作"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">2.1 原子类型与原子操作</span></span></a></li><li><a class="level is-mobile" href="#2-2-内存模型、顺序一致性和memory-order"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">2.2 内存模型、顺序一致性和memory_order</span></span></a></li><li><a class="level is-mobile" href="#2-3-内存栅栏"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">2.3 内存栅栏</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/C-Tools/"><span class="level-start"><span class="level-item">C++ Tools</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">数据结构与算法</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%9D%82%E9%A1%B9/"><span class="level-start"><span class="level-item">杂项</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">计算机网络</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-18T06:06:24.000Z">2023-04-18</time></p><p class="title"><a href="/2023/04/18/%E5%9F%BA%E4%BA%8E%E9%94%81%E7%9A%84%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C/">基于锁的并发数据结构(C++)</a></p><p class="categories"><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a> / <a href="/categories/C/">C++</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-17T07:48:55.000Z">2023-04-17</time></p><p class="title"><a href="/2023/04/17/%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/">线程间共享数据</a></p><p class="categories"><a href="/categories/C/">C++</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-14T02:36:32.000Z">2023-04-14</time></p><p class="title"><a href="/2023/04/14/%E5%89%96%E6%9E%90HTTPS/">剖析HTTPS</a></p><p class="categories"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-12T03:49:50.000Z">2023-04-12</time></p><p class="title"><a href="/2023/04/12/%E4%BD%BF%E7%94%A8chatgpt%E7%BB%83%E4%B9%A0gdb/">使用chatgpt练习gdb</a></p><p class="categories"><a href="/categories/C-Tools/">C++ Tools</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-11T02:19:49.000Z">2023-04-11</time></p><p class="title"><a href="/2023/04/11/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">常见排序算法</a></p><p class="categories"><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li></ul></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">MK&#039;s Blog</a><p class="is-size-7"><span>&copy; 2023 MK</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>