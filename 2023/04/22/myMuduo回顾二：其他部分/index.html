<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>myMuduo回顾二：其他部分 - MK&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="MK&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="MK&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content=""><meta property="og:type" content="blog"><meta property="og:title" content="myMuduo回顾二：其他部分"><meta property="og:url" content="http://mkmq99.github.io/2023/04/22/myMuduo%E5%9B%9E%E9%A1%BE%E4%BA%8C%EF%BC%9A%E5%85%B6%E4%BB%96%E9%83%A8%E5%88%86/"><meta property="og:site_name" content="MK&#039;s Blog"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://mkmq99.github.io/2023/04/22/myMuduo%E5%9B%9E%E9%A1%BE%E4%BA%8C%EF%BC%9A%E5%85%B6%E4%BB%96%E9%83%A8%E5%88%86/0.png"><meta property="og:image" content="http://mkmq99.github.io/2023/04/22/myMuduo%E5%9B%9E%E9%A1%BE%E4%BA%8C%EF%BC%9A%E5%85%B6%E4%BB%96%E9%83%A8%E5%88%86/1.png"><meta property="og:image" content="http://mkmq99.github.io/2023/04/22/myMuduo%E5%9B%9E%E9%A1%BE%E4%BA%8C%EF%BC%9A%E5%85%B6%E4%BB%96%E9%83%A8%E5%88%86/2.png"><meta property="og:image" content="http://mkmq99.github.io/2023/04/22/myMuduo%E5%9B%9E%E9%A1%BE%E4%BA%8C%EF%BC%9A%E5%85%B6%E4%BB%96%E9%83%A8%E5%88%86/3.png"><meta property="og:image" content="http://mkmq99.github.io/2023/04/22/myMuduo%E5%9B%9E%E9%A1%BE%E4%BA%8C%EF%BC%9A%E5%85%B6%E4%BB%96%E9%83%A8%E5%88%86/4.png"><meta property="og:image" content="http://mkmq99.github.io/2023/04/22/myMuduo%E5%9B%9E%E9%A1%BE%E4%BA%8C%EF%BC%9A%E5%85%B6%E4%BB%96%E9%83%A8%E5%88%86/5.png"><meta property="article:published_time" content="2023-04-22T13:23:33.000Z"><meta property="article:modified_time" content="2023-04-24T04:17:52.462Z"><meta property="article:author" content="MK"><meta property="article:tag" content="C++"><meta property="article:tag" content="多线程"><meta property="article:tag" content="并发"><meta property="article:tag" content="网络库"><meta property="article:tag" content="服务器"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://mkmq99.github.io/2023/04/22/myMuduo%E5%9B%9E%E9%A1%BE%E4%BA%8C%EF%BC%9A%E5%85%B6%E4%BB%96%E9%83%A8%E5%88%86/0.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://mkmq99.github.io/2023/04/22/myMuduo%E5%9B%9E%E9%A1%BE%E4%BA%8C%EF%BC%9A%E5%85%B6%E4%BB%96%E9%83%A8%E5%88%86/"},"headline":"myMuduo回顾二：其他部分","image":["http://mkmq99.github.io/2023/04/22/myMuduo%E5%9B%9E%E9%A1%BE%E4%BA%8C%EF%BC%9A%E5%85%B6%E4%BB%96%E9%83%A8%E5%88%86/0.png","http://mkmq99.github.io/2023/04/22/myMuduo%E5%9B%9E%E9%A1%BE%E4%BA%8C%EF%BC%9A%E5%85%B6%E4%BB%96%E9%83%A8%E5%88%86/1.png","http://mkmq99.github.io/2023/04/22/myMuduo%E5%9B%9E%E9%A1%BE%E4%BA%8C%EF%BC%9A%E5%85%B6%E4%BB%96%E9%83%A8%E5%88%86/2.png","http://mkmq99.github.io/2023/04/22/myMuduo%E5%9B%9E%E9%A1%BE%E4%BA%8C%EF%BC%9A%E5%85%B6%E4%BB%96%E9%83%A8%E5%88%86/3.png","http://mkmq99.github.io/2023/04/22/myMuduo%E5%9B%9E%E9%A1%BE%E4%BA%8C%EF%BC%9A%E5%85%B6%E4%BB%96%E9%83%A8%E5%88%86/4.png","http://mkmq99.github.io/2023/04/22/myMuduo%E5%9B%9E%E9%A1%BE%E4%BA%8C%EF%BC%9A%E5%85%B6%E4%BB%96%E9%83%A8%E5%88%86/5.png"],"datePublished":"2023-04-22T13:23:33.000Z","dateModified":"2023-04-24T04:17:52.462Z","author":{"@type":"Person","name":"MK"},"publisher":{"@type":"Organization","name":"MK's Blog","logo":{"@type":"ImageObject","url":{"text":"MK's Blog"}}},"description":""}</script><link rel="canonical" href="http://mkmq99.github.io/2023/04/22/myMuduo%E5%9B%9E%E9%A1%BE%E4%BA%8C%EF%BC%9A%E5%85%B6%E4%BB%96%E9%83%A8%E5%88%86/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">MK&#039;s Blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-04-22T13:23:33.000Z" title="2023/4/22 21:23:33">2023-04-22</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-04-24T04:17:52.462Z" title="2023/4/24 12:17:52">2023-04-24</time></span><span class="level-item"><a class="link-muted" href="/categories/C/">C++</a><span> / </span><a class="link-muted" href="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/">服务器</a></span><span class="level-item">an hour read (About 7216 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">myMuduo回顾二：其他部分</h1><div class="content"><p><img src="/2023/04/22/myMuduo%E5%9B%9E%E9%A1%BE%E4%BA%8C%EF%BC%9A%E5%85%B6%E4%BB%96%E9%83%A8%E5%88%86/0.png"></p>
<span id="more"></span>

<h3 id="1-epoll的具体使用"><a href="#1-epoll的具体使用" class="headerlink" title="1 epoll的具体使用"></a>1 epoll的具体使用</h3><h4 id="1-1-创建epoll"><a href="#1-1-创建epoll" class="headerlink" title="1.1 创建epoll"></a>1.1 创建epoll</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create1</span><span class="params">(<span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<p>epoll_create() 可以创建一个epoll实例。在linux 内核版本大于2.6.8 后，这个size 参数就被弃用了，但是传入的值必须大于0。epoll_create() 会返回新的epoll对象的文件描述符。这个文件描述符用于后续的epoll操作。如果不需要使用这个描述符，请使用close关闭。</p>
<p>epoll_create1() 如果flags的值是0，epoll_create1()等同于epoll_create()。当然flags可以使用 EPOLL_CLOEXEC，和 open() 中的O_CLOEXEC 效果相同，主要是关闭子进程复制的父进程的文件描述符。</p>
<h4 id="1-2-设置epoll事件"><a href="#1-2-设置epoll事件" class="headerlink" title="1.2 设置epoll事件"></a>1.2 设置epoll事件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个系统调用能够控制给定的文件描述符epfd指向的epoll实例，op是添加事件的类型，fd是目标文件描述符。</p>
<p>有效的op值有以下几种：</p>
<ul>
<li><p>EPOLL_CTL_ADD 在epfd中注册指定的fd文件描述符并指定fd相关的event。</p>
</li>
<li><p>EPOLL_CTL_MOD 改变fd相关联的event。</p>
</li>
<li><p>EPOLL_CTL_DEL 从指定的epfd中删除fd文件描述符。在这种模式中event是被忽略的，并且为可以等于NULL。</p>
</li>
</ul>
<p><strong>epoll_event</strong>的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span> &#123;</span><br><span class="line">    <span class="type">void</span>        *ptr;</span><br><span class="line">    <span class="type">int</span>          fd;</span><br><span class="line">    <span class="type">uint32_t</span>     u32;</span><br><span class="line">    <span class="type">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-等待epoll事件"><a href="#1-3-等待epoll事件" class="headerlink" title="1.3 等待epoll事件"></a>1.3 等待epoll事件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>epoll_wait等待文件描述符epfd引用的epoll实例上的事件。事件所指向的存储区域将包含可供调用者使用的事件。 epoll_wait最多返回maxevents个事件。maxevents参数必须大于零。timeout参数指定epoll_wait将阻塞的毫秒数，会一直阻塞到下面几种情况：</p>
<ul>
<li><p>一个文件描述符触发了事件。</p>
</li>
<li><p>被一个信号处理函数打断，或者timeout超时。</p>
</li>
</ul>
<p>指定超时值为-1会导致epoll_wait无限期阻塞，而指定的超时时间等于0导致epoll_wait立即返回，即使没有可用事件。</p>
<h3 id="2-常见并发模型"><a href="#2-常见并发模型" class="headerlink" title="2 常见并发模型"></a>2 常见并发模型</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_22473333/article/details/113547285">(58条消息) muduo库学习之详解muduo多线程模型（常见的并发网络服务器设计方案）_东阳z的博客-CSDN博客</a></p>
<p><img src="/2023/04/22/myMuduo%E5%9B%9E%E9%A1%BE%E4%BA%8C%EF%BC%9A%E5%85%B6%E4%BB%96%E9%83%A8%E5%88%86/1.png"></p>
<h3 id="3-Reactor和Proactor模型"><a href="#3-Reactor和Proactor模型" class="headerlink" title="3 Reactor和Proactor模型"></a>3 Reactor和Proactor模型</h3><p>在网络<strong>IO</strong>设计中，有两种高性能模型：<strong>Reactor</strong>模型和<strong>Proactor</strong>模型。<strong>Reactor</strong>基于同步<strong>IO</strong>模式，<strong>Proactor</strong>基于异步<strong>IO</strong>模式。</p>
<h4 id="3-1-Reactor-模型"><a href="#3-1-Reactor-模型" class="headerlink" title="3.1 Reactor 模型"></a>3.1 Reactor 模型</h4><p>Reactor模型可以分为：单Reactor单线程、单Reactor多线程、主从Reactor多线程</p>
<p>Reactor模型的核心是：Reactor+Handles。Reactor在一个单独的线程中运行，负责监听和分发事件，将接收到的io事件交给不同的Handle来处理响应。Handles是处理程序执行I&#x2F;O事件的实际操作，Reactor通过调度适当的Handles来处理io事件。</p>
<h5 id="3-1-1-单Reactor单线程"><a href="#3-1-1-单Reactor单线程" class="headerlink" title="3.1.1 单Reactor单线程"></a>3.1.1 单Reactor单线程</h5><p><img src="/2023/04/22/myMuduo%E5%9B%9E%E9%A1%BE%E4%BA%8C%EF%BC%9A%E5%85%B6%E4%BB%96%E9%83%A8%E5%88%86/2.png"></p>
<p><strong>流程：</strong></p>
<ol>
<li>Reactor 对象通过 <strong>Select 监控客户端请求事件，收到事件后通过 Dispatch 进行分发。</strong></li>
<li>如果是建立连接请求事件，则由 Acceptor 通过 Accept 处理连接请求，然后创建一个 Handler 对象处理连接完成后的后续业务处理。</li>
<li>如果不是建立连接事件，则 Reactor 会分发调用连接对应的 Handler 来响应</li>
<li>Handler 会完成 Read→业务处理→Send 的完整业务流程。</li>
</ol>
<p><strong>优点：</strong></p>
<ol>
<li>模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>性能问题，只有一个线程，无法完全发挥多核 CPU 的性能。Handler 在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能阻塞。</li>
<li>可靠性问题，线程意外终止，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障。</li>
</ol>
<p><strong>使用场景：</strong><br>客户端的数量有限，业务处理非常快速。java原生nio就是这个模型。</p>
<h5 id="3-1-2-单Reactor多线程"><a href="#3-1-2-单Reactor多线程" class="headerlink" title="3.1.2 单Reactor多线程"></a>3.1.2 单Reactor多线程</h5><p><img src="/2023/04/22/myMuduo%E5%9B%9E%E9%A1%BE%E4%BA%8C%EF%BC%9A%E5%85%B6%E4%BB%96%E9%83%A8%E5%88%86/3.png"></p>
<p><strong>流程：</strong></p>
<ol>
<li>Reactor 对象<strong>通过select 监控客户端请求事件, 收到事件后，通过dispatch进行分发。</strong></li>
<li>如果建立连接请求, 则由Acceptor 通过accept 处理连接请求, 然后创建一个Handler对象处理完成连接后的各种事件。</li>
<li>如果不是连接请求，则由reactor分发调用连接对应的handler 来处理。</li>
<li>handler 只负责响应事件，不做具体的业务处理, 通过read 读取数据后，会分发给后面的worker线程池的某个线程处理业务。</li>
<li>worker 线程池会分配独立线程完成真正的业务，并将结果返回给handler。</li>
<li>handler收到响应后，通过send 将结果返回给client。</li>
</ol>
<p><strong>优点：</strong></p>
<ol>
<li>可以充分的利用多核cpu 的处理能力。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>多线程数据共享和访问比较复杂， reactor 处理所有的事件的监听和响应，在单线程运行， 在高并发场景容易出现性能瓶颈.。</li>
</ol>
<h5 id="3-1-3-主从Reactor多线程"><a href="#3-1-3-主从Reactor多线程" class="headerlink" title="3.1.3 主从Reactor多线程"></a>3.1.3 主从Reactor多线程</h5><p><img src="/2023/04/22/myMuduo%E5%9B%9E%E9%A1%BE%E4%BA%8C%EF%BC%9A%E5%85%B6%E4%BB%96%E9%83%A8%E5%88%86/4.png"></p>
<p><strong>流程：</strong></p>
<ol>
<li>Reactor主线程 MainReactor 对象<strong>通过select 监听连接事件, 收到事件后，通过Acceptor 处理连接事件。</strong></li>
<li>当 Acceptor 处理连接事件后，MainReactor 将连接分配给SubReactor 。</li>
<li>subreactor 将连接加入到连接队列进行监听,并创建handler进行各种事件处理。</li>
<li>当有新事件发生时，subreactor 就会调用对应的handler处理。</li>
<li>handler 通过read 读取数据，分发给后面的worker 线程处理。</li>
<li>worker 线程池分配独立的worker 线程进行业务处理，并返回结果。</li>
<li>handler 收到响应的结果后，再通过send 将结果返回给client。</li>
<li>Reactor 主线程可以对应多个Reactor 子线程, 即MainRecator 可以关联多个SubReactor。</li>
</ol>
<p><strong>优点：</strong></p>
<ol>
<li>父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理。</li>
<li>父线程与子线程的数据交互简单，Reactor 主线程只需要把新连接传给子线程，子线程无需返回数据。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>编程复杂度较高。</li>
</ol>
<p><strong>应用场景：</strong><br>这种模型在许多项目中广泛使用，包括 Nginx 主从 Reactor 多进程模型，Memcached 主从多线程，Netty 主从多线程模型的支持。</p>
<h4 id="3-2-Proactor模型"><a href="#3-2-Proactor模型" class="headerlink" title="3.2 Proactor模型"></a>3.2 Proactor模型</h4><p>Proactor 模式整体与Reactor 模式一致，区别就在于Proactor模式将所有I&#x2F;O操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。</p>
<p>这里需要注意的是： <strong>Proactor关注的不是就绪事件，而是完成事件，这是区分Reactor模式的关键点</strong>。</p>
<p>然而可惜的是，Linux下的异步 I&#x2F;O 是不完善的，<code>aio</code> 系列函数是由 <code>POSIX</code> 定义的异步操作接口，不是真正的操作系统级别支持的，而是在用户空间模拟出来的异步，并且仅仅支持基于本地文件的 <code>aio</code> 异步操作，网络编程中的 <code>socket </code>是不支持的，这也使得基于 Linux 的高性能网络程序都是使用 Reactor 方案。</p>
<p><strong>优点</strong></p>
<ol>
<li>性能确实是强大，效率也高</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>复杂。性能好，效率高，东西是好东西，但是使用起来就是复杂。</li>
<li>操作系统支持。上面提到过，Linux系统对异步IO支持不是很好，不是很完善</li>
</ol>
<h4 id="3-3-两者的区别"><a href="#3-3-两者的区别" class="headerlink" title="3.3 两者的区别"></a>3.3 两者的区别</h4><ul>
<li>Reactor 模式注册的是文件描述符的就绪事件。当Reactor 模式有事件发生时，它需要判断当前事件是读事件还是写事件，然后在调用系统的<code>read</code>或者<code>write</code>将数据从内核中拷贝到用户数据区，然后进行业务处理。</li>
<li>Proactor模式注册的则是完成事件。即发起异步操作后，操作系统将在内核态完成I&#x2F;O并拷贝数据到用户提供的缓冲区中，完成后通知Proactor进行回调，用户只需要处理后续的业务即可。</li>
<li>Reactor模式实现<code>同步I/O多路分发</code></li>
<li>Proactor模式实现<code>异步I/O分发</code>。</li>
</ul>
<h3 id="4-muduo的主线程accept的fd如何分发给其他线程？"><a href="#4-muduo的主线程accept的fd如何分发给其他线程？" class="headerlink" title="4 muduo的主线程accept的fd如何分发给其他线程？"></a>4 muduo的主线程accept的fd如何分发给其他线程？</h3><p>首先TcpServer初始化的时候会有一个mainLoop，Acceptor对应的Channel就是在mainLoop对应的Poller中注册事件的。一旦有了新连接，Poller就会上报EventLoop，通知channel处理相应事件。那么这里Channel回回调TcpServer::newConnection函数，再由它来分发给subLoop。再创建TcpConnection对应这个subLoop，subLoop去执行TcpConnection::connectEstablished()，在这函数里由对应的channel注册事件。</p>
<h3 id="5-muduo定时器的实现"><a href="#5-muduo定时器的实现" class="headerlink" title="5 muduo定时器的实现"></a>5 muduo定时器的实现</h3><p>在常见的定时函数中muduo选择<code>timerfd</code>实现定时器，原因如下：</p>
<ol>
<li>sleep &#x2F; alarm &#x2F; usleep在实现时有可能使用了SIGALRM信号，<strong>多线程程序中尽量避免使用信号</strong>，因为处理起来比较麻烦（信号通知进程，所有线程都将接收到这个信号，谁处理好）。另外，如果网络库定义了信号处理函数，用户代码(main函数等使用库的程序)也定义了信号处理函数，这不就冲突了，该调用哪个好。</li>
<li>nanosleep &#x2F; clock_nanosleep是线程安全的，但是会让当前线程挂起等待一段时间，这会导致线程失去响应。在非阻塞网络编程中，绝对不能让线程挂起的方式来等待一段事件。正确的做法是注册一个事件回调函数。</li>
<li>gettimer和timer_create也是用信号来传递超时信息，在多线程中程序中也会有麻烦。</li>
<li>timerfd_create <strong>把时间变成了一个文件描述符，该描述符在定时器超时的那一刻变为可读，可以很方便的融入到select&#x2F;poll&#x2F;epoll中</strong>，用同一的方式来处理IO事件和超时事件。</li>
</ol>
<h4 id="5-1-定时任务的原理"><a href="#5-1-定时任务的原理" class="headerlink" title="5.1 定时任务的原理"></a>5.1 定时任务的原理</h4><ol>
<li>muduo采用<code>timerfd_*</code><strong>将超时任务转换成文件描述符进行监听</strong></li>
<li>当时间一到，<code>timerfd</code>变为可读，相应的<code>Channel</code>调用回调函数(TimerQueue::handleRead)</li>
<li>回调函数中将所有在<code>TimerQueue</code>中的超时任务找出，一次调用其回调函数</li>
<li>对于周期性定时任务，再添加回<code>TimerQueue</code>中</li>
</ol>
<p><img src="/2023/04/22/myMuduo%E5%9B%9E%E9%A1%BE%E4%BA%8C%EF%BC%9A%E5%85%B6%E4%BB%96%E9%83%A8%E5%88%86/5.png"></p>
<p>整个过程只有一个<code>timerfd</code>被<code>Poller</code>监听，所以调用<code>timerfd_settime</code>设置的超时时间一定是<code>TimerQueue</code>的<code>set/map</code>里最小的，即<code>set.begin();</code>第一个Timer任务。</p>
<p>而用户是通过调用<code>EventLoop::runAt/runAfter/runEvery</code>这些EventLoop的函数注册定时任务的，这些函数都需要向<code>TimerQueue</code>的<code>set</code>或者<code>map</code>中添加<code>Timer</code>，所以每添加一个都需要判断新添加的定时任务的超时时间是否小于设置的超时时间，如果小于，就需要调用timerfd_settime重新设置timerfd的超时时间。</p>
<p><strong>而每次timerfd被激活都需要找到在set中所有的超时任务</strong>，因为有可能存在超时时间相等的定时任务，可以使用<code>std::lower_bound</code>函数找到第一个大于等于给定值的位置。</p>
<h4 id="5-2-muduo定时器涉及的类"><a href="#5-2-muduo定时器涉及的类" class="headerlink" title="5.2 muduo定时器涉及的类"></a>5.2 muduo定时器涉及的类</h4><p>muduo的定时器功能由三个类实现，<code>TimerId</code>、<code>Timer</code>、<code>TimerQueue</code>：</p>
<ul>
<li><p><code>Timer</code>类是一个超时任务，保存超时时间，回调函数，以及记录自己是否是周期性计时任务，回调函数是用户提供的。</p>
</li>
<li><p><code>TimerId</code>类用于保存超时任务Timer和它独一无二的id。</p>
</li>
<li><p><code>TimerQueue</code>类保存用户设置的所有超时任务，需要高效保存尚未超时的任务，同时需要<strong>有序</strong>，方便找到超时时间最近的那个任务，可以用最小堆（libevent采用），也可以用<code>std::set</code>或者<code>set::map</code>存储（muduo采用）。</p>
</li>
</ul>
<h4 id="5-3-Timer类"><a href="#5-3-Timer类" class="headerlink" title="5.3 Timer类"></a>5.3 Timer类</h4><p>Timer封装了定时器的一些参数，例如超时回调函数、超时时间、定时器是否重复、重复间隔时间、定时器的序列号。其函数大都是设置这些参数，run()用来调用回调函数，restart()用来重启定时器（如果设置为重复）。其源码相对简单</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span> : noncopyable </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Timer</span>(<span class="type">const</span> TimerCallback &amp;cb, Timestamp when, <span class="type">double</span> interval)</span><br><span class="line">        : <span class="built_in">callback_</span>(cb),<span class="comment">//回调函数</span></span><br><span class="line">    <span class="built_in">expiration_</span>(when),<span class="comment">//超时时间</span></span><br><span class="line">    <span class="built_in">interval_</span>(interval),<span class="comment">//如果重复，间隔时间</span></span><br><span class="line">    <span class="built_in">repeat_</span>(interval &gt; <span class="number">0.0</span>),<span class="comment">//如果间隔大于0，就重复</span></span><br><span class="line">    <span class="built_in">sequence_</span>(s_numCreated_.<span class="built_in">incrementAndGet</span>()) &#123;&#125;<span class="comment">//当前定时器的序列号</span></span><br><span class="line">    <span class="comment">//调用回调函数.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">callback_</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Timestamp <span class="title">expiration</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> expiration_; &#125;<span class="comment">//返回超时时刻</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeat</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> repeat_; &#125;<span class="comment">//返回是否重复</span></span><br><span class="line">    <span class="function"><span class="type">int64_t</span> <span class="title">sequence</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> sequence_; &#125;<span class="comment">//返回定时器序号</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">restart</span><span class="params">(Timestamp now)</span></span>;<span class="comment">//重新开始</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int64_t</span> <span class="title">numCreated</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s_numCreated_.<span class="built_in">get</span>(); &#125;<span class="comment">//返回最新的序号值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> TimerCallback callback_;        <span class="comment">// 定时器回调函数</span></span><br><span class="line">    Timestamp expiration_;                <span class="comment">// 下一次的超时时间戳类</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> interval_;                <span class="comment">// 超时时间间隔，如果是一次性定时器，该值为0</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> repeat_;                    <span class="comment">// 是否重复</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int64_t</span> sequence_;                <span class="comment">// 定时器序号，不会重复</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> AtomicInt64 s_numCreated_;        <span class="comment">// 定时器计数，当前已经创建的定时器数量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5-4-TimerId类"><a href="#5-4-TimerId类" class="headerlink" title="5.4 TimerId类"></a>5.4 TimerId类</h4><p>TimerId非常简单，它被设计用来取消Timer的，它的结构很简单，只有一个Timer指针和其序列号。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimerId</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TimerId</span>()</span><br><span class="line">        : <span class="built_in">timer_</span>(<span class="literal">NULL</span>),</span><br><span class="line">    <span class="built_in">sequence_</span>(<span class="number">0</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TimerId</span>(Timer *timer, <span class="type">int64_t</span> seq)</span><br><span class="line">        : <span class="built_in">timer_</span>(timer),</span><br><span class="line">    <span class="built_in">sequence_</span>(seq) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">TimerQueue</span>;<span class="comment">//友元，就是可以访问类的私有成员变量，但不是类中的成员</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Timer *timer_;</span><br><span class="line">    <span class="type">int64_t</span> sequence_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5-5-TimerQueue类"><a href="#5-5-TimerQueue类" class="headerlink" title="5.5 TimerQueue类"></a>5.5 TimerQueue类</h4><p>虽然TimerQueue中有Queue，但是其实现时基于Set的，而不是Queue。这样可以高效地插入、删除定时器，且找到当前已经超时的定时器。TimerQueue的public接口只有两个，添加和删除。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一定是线程安全的，可以跨线程调用。通常情况下被其它线程调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addTimerInLoop</span><span class="params">(Timer* timer)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cancelInLoop</span><span class="params">(TimerId timerId)</span></span>;</span><br></pre></td></tr></table></figure>

<p>类定义的源码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimerQueue</span> : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">TimerQueue</span><span class="params">(EventLoop* loop)</span></span>;</span><br><span class="line">	~<span class="built_in">TimerQueue</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加定时器接口，函数返回定时器唯一ID</span></span><br><span class="line">	<span class="function">TimerId <span class="title">addTimer</span><span class="params">(TimerCallback cb, <span class="comment">//回调函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">                   Timestamp when,   <span class="comment">//超时时间</span></span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">double</span> interval)</span></span>; <span class="comment">//时间间隔</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 取消定时器，通过addTimer()返回的定时器唯一ID</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">cancel</span><span class="params">(TimerId timerId)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 定时器容器的相关数据结构</span></span><br><span class="line">	<span class="keyword">typedef</span> std::pair&lt;Timestamp, Timer*&gt; Entry;</span><br><span class="line">	<span class="keyword">typedef</span> std::set&lt;Entry&gt; TimerList;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用于记录活跃定时器和取消定时器容器的相关数据结构</span></span><br><span class="line">	<span class="keyword">typedef</span> std::pair&lt;Timer*, <span class="type">int64_t</span>&gt; ActiveTimer;</span><br><span class="line">	<span class="keyword">typedef</span> std::set&lt;ActiveTimer&gt; ActiveTimerSet;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 由EventLoop::runInLoop()触发添加定时器</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">addTimerInLoop</span><span class="params">(Timer* timer)</span></span>;</span><br><span class="line">	<span class="comment">// 由EventLoop::runInLoop()触发取消定时器</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">cancelInLoop</span><span class="params">(TimerId timerId)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定时器超时的处理函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">handleRead</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 从定时器列表中找到所有到期的定时器</span></span><br><span class="line">	<span class="function">std::vector&lt;Entry&gt; <span class="title">getExpired</span><span class="params">(Timestamp now)</span></span>;</span><br><span class="line">	<span class="comment">// 将重复的超时定时器重新添加到定时器列表timers_中</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(<span class="type">const</span> std::vector&lt;Entry&gt;&amp; expired, Timestamp now)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加定时器到容器</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(Timer* timer)</span></span>;</span><br><span class="line"></span><br><span class="line">	EventLoop* loop_; <span class="comment">//所属的事件循环</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> timerfd_; <span class="comment">//timerfd_create()创建的文件描述符</span></span><br><span class="line">	Channel timerfdChannel_; <span class="comment">//用于监听timerfd的Channel</span></span><br><span class="line">	TimerList timers_; <span class="comment">//定时器列表</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用于取消定时器，通过唯一ID找到对应的定时器</span></span><br><span class="line">	ActiveTimerSet activeTimers_; <span class="comment">//活跃定时器记录</span></span><br><span class="line">	<span class="type">bool</span> callingExpiredTimers_;</span><br><span class="line">	ActiveTimerSet cancelingTimers_; <span class="comment">//取消定时器记录</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>首先，看下<code>TimerQueue</code>提供的添加定时器的接口函数<code>addTimer()</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TimerId <span class="title">TimerQueue::addTimer</span><span class="params">(TimerCallback cb,</span></span></span><br><span class="line"><span class="params"><span class="function">                             Timestamp when,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">double</span> interval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 创建定时器类</span></span><br><span class="line">	Timer* timer = <span class="keyword">new</span> <span class="built_in">Timer</span>(std::<span class="built_in">move</span>(cb), when, interval);</span><br><span class="line">	loop_-&gt;<span class="built_in">runInLoop</span>(</span><br><span class="line">    	std::<span class="built_in">bind</span>(&amp;TimerQueue::addTimerInLoop, <span class="keyword">this</span>, timer));</span><br><span class="line">	<span class="comment">// 返回定时器唯一ID</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">TimerId</span>(timer, timer-&gt;<span class="built_in">sequence</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>addTimer()</code>通过所属的事件循环调用<code>EventLoop::runInLoop()</code>触发添加定时器函数<code>TimerQueue::addTimerInLoop()</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TimerQueue::addTimerInLoop</span><span class="params">(Timer* timer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">	<span class="type">bool</span> earliestChanged = <span class="built_in">insert</span>(timer);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断是否需要更新 timerfd 的超时时间</span></span><br><span class="line">	<span class="keyword">if</span> (earliestChanged)</span><br><span class="line">	&#123;</span><br><span class="line">    	<span class="built_in">resetTimerfd</span>(timerfd_, timer-&gt;<span class="built_in">expiration</span>());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>addTimerInLoop()</code>实际就是调用了<code>TimerQueue::insert()</code>来添加定时器到容器中。如果定时器容器为空或者新添加的定时器位于容器的顶部，即超时时间比当前小，就通过<code>resetTimerfd()</code>(<code>timerfd_settime()</code>的封装)来更新超时时间。</p>
<p><code>insert()</code>源码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TimerQueue::insert</span><span class="params">(Timer* timer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="built_in">assert</span>(timers_.<span class="built_in">size</span>() == activeTimers_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="type">bool</span> earliestChanged = <span class="literal">false</span>;</span><br><span class="line">    Timestamp when = timer-&gt;<span class="built_in">expiration</span>();</span><br><span class="line">    TimerList::iterator it = timers_.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span> (it == timers_.<span class="built_in">end</span>() || when &lt; it-&gt;first) <span class="comment">//定时器容器为空 或 超时时间比当前小</span></span><br><span class="line">    &#123;</span><br><span class="line">        earliestChanged = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 添加到定时器列表 timers_ 中</span></span><br><span class="line">        std::pair&lt;TimerList::iterator, <span class="type">bool</span>&gt; result</span><br><span class="line">            = timers_.<span class="built_in">insert</span>(<span class="built_in">Entry</span>(when, timer));</span><br><span class="line">        <span class="built_in">assert</span>(result.second); (<span class="type">void</span>)result;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 添加到活跃定时器列表 activeTimers_ 中，用于取消定时器是查找</span></span><br><span class="line">        std::pair&lt;ActiveTimerSet::iterator, <span class="type">bool</span>&gt; result</span><br><span class="line">            = activeTimers_.<span class="built_in">insert</span>(<span class="built_in">ActiveTimer</span>(timer, timer-&gt;<span class="built_in">sequence</span>()));</span><br><span class="line">        <span class="built_in">assert</span>(result.second); (<span class="type">void</span>)result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(timers_.<span class="built_in">size</span>() == activeTimers_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> earliestChanged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定时器添加的流程就是：<code>addTimer()</code>&#x3D;&gt;<code>EventLoop::runInLoop()</code>&#x3D;&gt;<code>addTimerInLoop()</code>&#x3D;&gt;<code>insert()</code>。<br>但是使用时，并不直接调用<code>addTimer()</code>，<code>EventLoop</code>对其做了更加完善的封装，提供给用户，接口如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TimerId <span class="title">EventLoop::runAt</span><span class="params">(Timestamp time, TimerCallback cb)</span> </span>&#123; /... &#125;</span><br><span class="line"><span class="function">TimerId <span class="title">EventLoop::runAfter</span><span class="params">(<span class="type">double</span> delay, TimerCallback cb)</span> </span>&#123; /... &#125;</span><br><span class="line"><span class="function">TimerId <span class="title">EventLoop::runEvery</span><span class="params">(<span class="type">double</span> interval, TimerCallback cb)</span> </span>&#123; /... &#125;</span><br></pre></td></tr></table></figure>

<p>当<code>timerfd</code>超时，调用定时器超时的处理函数<code>TimerQueue::handleRead()</code>，此函数在容器构造时通过<code>Channel</code>注册，源码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TimerQueue::<span class="built_in">TimerQueue</span>(EventLoop* loop)</span><br><span class="line">  : <span class="built_in">loop_</span>(loop),</span><br><span class="line">    <span class="built_in">timerfd_</span>(<span class="built_in">createTimerfd</span>()),</span><br><span class="line">    <span class="built_in">timerfdChannel_</span>(loop, timerfd_),</span><br><span class="line">    <span class="built_in">timers_</span>(),</span><br><span class="line">    <span class="built_in">callingExpiredTimers_</span>(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">  timerfdChannel_.<span class="built_in">setReadCallback</span>(</span><br><span class="line">      std::<span class="built_in">bind</span>(&amp;TimerQueue::handleRead, <span class="keyword">this</span>));</span><br><span class="line">  timerfdChannel_.<span class="built_in">enableReading</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>handleRead()</code>通过<code>TimerQueue::getExpired()</code>从定时器列表中找到所有到期的定时器，然后依次执行其回调函数，并将重复的超时定时器重新添加到定时器列表<code>timers_</code>中，源码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TimerQueue::handleRead</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="function">Timestamp <span class="title">now</span><span class="params">(Timestamp::now())</span></span>;</span><br><span class="line">    <span class="built_in">readTimerfd</span>(timerfd_, now);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从定时器列表中找到所有到期的定时器</span></span><br><span class="line">    std::vector&lt;Entry&gt; expired = <span class="built_in">getExpired</span>(now);</span><br><span class="line"></span><br><span class="line">    callingExpiredTimers_ = <span class="literal">true</span>;</span><br><span class="line">    cancelingTimers_.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> Entry&amp; it : expired)</span><br><span class="line">    &#123;</span><br><span class="line">        it.second-&gt;<span class="built_in">run</span>(); <span class="comment">//依次执行其回调函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    callingExpiredTimers_ = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将重复的超时定时器重新添加到定时器列表 timers_ 中</span></span><br><span class="line">    <span class="built_in">reset</span>(expired, now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;TimerQueue::Entry&gt; <span class="title">TimerQueue::getExpired</span><span class="params">(Timestamp now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(timers_.<span class="built_in">size</span>() == activeTimers_.<span class="built_in">size</span>());</span><br><span class="line">    std::vector&lt;Entry&gt; expired;</span><br><span class="line">    <span class="function">Entry <span class="title">sentry</span><span class="params">(now, <span class="keyword">reinterpret_cast</span>&lt;Timer*&gt;(UINTPTR_MAX))</span></span>;</span><br><span class="line">    <span class="comment">// 利用 lower_bound() 找到第一个大于等于参数的位置，返回迭代器</span></span><br><span class="line">    TimerList::iterator end = timers_.<span class="built_in">lower_bound</span>(sentry);</span><br><span class="line">    <span class="built_in">assert</span>(end == timers_.<span class="built_in">end</span>() || now &lt; end-&gt;first);</span><br><span class="line">    <span class="comment">// 构造vector&lt;Entry&gt;</span></span><br><span class="line">    std::<span class="built_in">copy</span>(timers_.<span class="built_in">begin</span>(), end, <span class="built_in">back_inserter</span>(expired));</span><br><span class="line">    timers_.<span class="built_in">erase</span>(timers_.<span class="built_in">begin</span>(), end);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> Entry&amp; it : expired)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">ActiveTimer <span class="title">timer</span><span class="params">(it.second, it.second-&gt;sequence())</span></span>;</span><br><span class="line">        <span class="type">size_t</span> n = activeTimers_.<span class="built_in">erase</span>(timer);</span><br><span class="line">        <span class="built_in">assert</span>(n == <span class="number">1</span>); (<span class="type">void</span>)n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(timers_.<span class="built_in">size</span>() == activeTimers_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> expired;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TimerQueue::reset</span><span class="params">(<span class="type">const</span> std::vector&lt;Entry&gt;&amp; expired, Timestamp now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Timestamp nextExpire;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> Entry&amp; it : expired)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">ActiveTimer <span class="title">timer</span><span class="params">(it.second, it.second-&gt;sequence())</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (it.second-&gt;<span class="built_in">repeat</span>() <span class="comment">//判断是否时重复定时器</span></span><br><span class="line">                &amp;&amp; cancelingTimers_.<span class="built_in">find</span>(timer) == cancelingTimers_.<span class="built_in">end</span>()) <span class="comment">//判断用户是否取消了这个定时任务</span></span><br><span class="line">        &#123;</span><br><span class="line">            it.second-&gt;<span class="built_in">restart</span>(now); <span class="comment">//重新计算超时时间</span></span><br><span class="line">            <span class="built_in">insert</span>(it.second); <span class="comment">//重新添加到容器中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> it.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算下次timerfd被激活的时间</span></span><br><span class="line">    <span class="keyword">if</span> (!timers_.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        nextExpire = timers_.<span class="built_in">begin</span>()-&gt;second-&gt;<span class="built_in">expiration</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置超时时间</span></span><br><span class="line">    <span class="keyword">if</span> (nextExpire.<span class="built_in">valid</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">resetTimerfd</span>(timerfd_, nextExpire);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-多线程情况下如何做到线程安全的对象生命期管理"><a href="#6-多线程情况下如何做到线程安全的对象生命期管理" class="headerlink" title="6 多线程情况下如何做到线程安全的对象生命期管理"></a>6 多线程情况下如何做到线程安全的对象生命期管理</h3><h4 id="6-1-对象构造"><a href="#6-1-对象构造" class="headerlink" title="6.1 对象构造"></a>6.1 对象构造</h4><p>对象构造要做到线程安全，唯一的要求是在构造期间不要泄露 this 指针</p>
<ul>
<li>不要在构造函数中注册任何回调</li>
<li>也不要在构造函数中把 this 传给跨线程的对象</li>
</ul>
<h4 id="6-2-连接更新、析构等操作"><a href="#6-2-连接更新、析构等操作" class="headerlink" title="6.2 连接更新、析构等操作"></a>6.2 连接更新、析构等操作</h4><p><strong>什么是线程安全</strong>：所谓线程安全是指凡是非共享的对象都是彼此独立的，如果一个对象从始至终只被一个线程用到，那么它就是安全的。共享的对象的read-only操作是安全的，前提是不能有并发的写操作。（如果有并发的写操作那么将会是线程不安全的），同样在多线程C++中还要注意多个线程如果都可以访问一个对象时的对象析构问题，所以对于这样的对象最好采取智能指针去管理。所以说在并发服务器里，对于同一个连接是不能够供多个线程同时进行读或者写，所以muduo库规定所有的读写操作只能在IO线程（包括连接关闭操作）中来完成。muduo库通过runInLoop和queueInLoop这两个函数来保证将可能在其他线程执行的IO操作放入到IO线程来完成。（比如在线程池中的线程可能会用到send操作或者close操作）</p>
<p><strong>muduo规定的必须在IO线程完成的操作：</strong>连接的更新、连接的读写、连接的关闭、连接的析构等</p>
<p>一些置于所属线程的例子：</p>
<ol>
<li>TcpServer::start():将Acceptor::listen置于所属线程：</li>
</ol>
<blockquote>
<p>一直不理解为什么这里需要将listen放到其所属线程中（因为listen的描述符一定是在IO线程中的）可能原因是其他从reactor线程中可能会创建监听描述符。</p>
</blockquote>
<ol start="2">
<li>TcpServer::newConnection():将TcpConnection::connectEstablished置于所属线程</li>
</ol>
<blockquote>
<p>这是肯定的，因为connectEstablished函数涉及连接的更新操作，这个函数应该由其连接所属的线程来调用，而此时的函数是监听fd所属的线程所以需要采取此操作。</p>
</blockquote>
<ol start="3">
<li>TcpServer::removeConnection:将removeConnectionInLoop置于所属线程</li>
</ol>
<blockquote>
<p>为了避免在删除map中的conn对象时出现竞争，muduo规定只能在map（也就是监听fd）所属的线程中进行删除操作，从而避免了多个线程使用map而造成的竞争。</p>
</blockquote>
<ol start="4">
<li>TcpServer::removeConnectionInLoop:将TcpConnection::connectDestroyed置于queueInLoop</li>
</ol>
<blockquote>
<p>此操作根本是保证channel不会在TcpConnection对象析构后而析构，因为handleRead等操作是由channel直接调用的，但是此函数可能会直接将channel析构调用从而出现段错误，所以采用此操作使得channel的析构推迟。</p>
</blockquote>
<ol start="5">
<li>TcpConnection::send:将TcpConnection::sendInLoop置于所属线程</li>
</ol>
<blockquote>
<p> 因为线程池的线程可能会采用send操作</p>
</blockquote>
<ol start="6">
<li>TcpConnection::shutdown将TcpConnection::shutdownInLoop置于所属线程</li>
</ol>
<blockquote>
<p>因为线程池中的线程可能会采用shutdown操作</p>
</blockquote>
<ol start="7">
<li>TcpServer::~TcpServer将TcpConnection::connectionDestroy置于所属线程</li>
</ol>
<blockquote>
<p>因为TcpServer在析构时需要关闭所有的连接，而析构函数是在监听fd所属的IO线程的，所有要采取此操作。</p>
</blockquote>
<ol start="8">
<li>TcpConnection::forceClose将TcpConnection::forceCloseInLoop置于所属线程</li>
</ol>
<blockquote>
<p>因为线程池中的线程可能会采用forceClose操作</p>
</blockquote>
<h3 id="7-muduo如何限制连接的数量？"><a href="#7-muduo如何限制连接的数量？" class="headerlink" title="7 muduo如何限制连接的数量？"></a>7 muduo如何限制连接的数量？</h3><p>服务器的文件描述符数量有限，因此需要一些手段来限制服务器的最大并发连接数。需要这么做的原因是：某个时刻服务器文件描述符已经用完了，此时再来一个连接，将无法用描述符表示这个连接，也就无法关闭这个连接。在Reactor模式下，<code>POLLIN</code>事件就会一直被触发（level trigger模式），就会进入busy loop，cpu 利用率将到达100%。</p>
<p>因此有必要设计一个策略，当服务器并发数目到达上限时，主动的拒接连接。muduo使用的办法很巧妙（？？？）：</p>
<blockquote>
<p>1.准备一个空闲的描述符<br>2.当遇到上述情况时，先close掉这个空闲的文件描述符，这样就多出一个可用描述符<br>3.接收新的连接后就有文件描述符来表示这个连接了。<br>4.此时close掉这个描述符，就关掉了客户端连接<br>5.再次打开这个空闲的描述符。</p>
</blockquote>
<p>并未在代码中找到上述策略，真实代码中貌似仅仅是在大于最大连接数时将连接shutdown了。</p>
<h3 id="8-muduo为什么用LT模式"><a href="#8-muduo为什么用LT模式" class="headerlink" title="8 muduo为什么用LT模式"></a>8 muduo为什么用LT模式</h3><ol>
<li>为了与传统的poll(2)兼容，因为在文件描述符数目较少， 活动文件描述符比例较高时，epoll(4)不见得比poll(2)更高效，必要时可以在进程启动时切换Poller。</li>
<li>level trigger编程更容易，以往 select(2)&#x2F;poll(2)的经验都可以继续用，不可能发生漏掉事件的bug。</li>
<li>读写的时候不必等候出现EAGAIN，可以节省系统调用次数，降低延迟。</li>
</ol>
<h3 id="9-LT模式和ET模式剖析"><a href="#9-LT模式和ET模式剖析" class="headerlink" title="9 LT模式和ET模式剖析"></a>9 LT模式和ET模式剖析</h3><p><strong>Level Triggered (LT) 水平触发</strong></p>
<ul>
<li>socket接收缓冲区不为空，有数据可读，读事件一直触发</li>
<li>socket发送缓冲区不满，可以继续写入数据，写事件一直触发</li>
<li>符合思维习惯，epoll_wait返回的事件就是socket的状态</li>
</ul>
<p><strong>Edge Triggered (ET) 边沿触发</strong></p>
<ul>
<li>socket的接收缓冲区状态变化时触发读事件，即空的接收缓冲区刚接收到数据时触发读事件</li>
<li>socket的发送缓冲区状态变化时触发写事件，即满的缓冲区刚空出空间时触发读事件</li>
<li>仅在状态变化时触发事件</li>
</ul>
<p><strong>LT的处理过程：</strong></p>
<ul>
<li>accept一个连接，添加到epoll中监听EPOLLIN事件</li>
<li>当EPOLLIN事件到达时，read fd中的数据并处理</li>
<li>当需要写出数据时，把数据write到fd中；如果数据较大，无法一次性写出，那么在epoll中监听EPOLLOUT事件</li>
<li>当EPOLLOUT事件到达时，继续把数据write到fd中；如果数据写出完毕，那么在epoll中关闭EPOLLOUT事件</li>
</ul>
<p><strong>ET的处理过程：</strong></p>
<ul>
<li>accept一个一个连接，添加到epoll中监听EPOLLIN|EPOLLOUT事件</li>
<li>当EPOLLIN事件到达时，read fd中的数据并处理，read需要一直读，直到返回EAGAIN为止</li>
<li>当需要写出数据时，把数据write到fd中，直到数据全部写完，或者write返回EAGAIN</li>
<li>当EPOLLOUT事件到达时，继续把数据write到fd中，直到数据全部写完，或者write返回EAGAIN</li>
</ul>
<p>从ET的处理过程中可以看到，ET的要求是需要一直读写，直到返回EAGAIN，否则就会遗漏事件。而LT的处理过程中，直到返回EAGAIN不是硬性要求，但通常的处理过程都会读写直到返回EAGAIN，但LT比ET多了一个开关EPOLLOUT事件的步骤。</p>
<p>LT的编程与poll&#x2F;select接近，符合一直以来的习惯，不易出错<br>ET的编程可以做到更加简洁，某些场景下更加高效，但另一方面容易遗漏事件，容易产生bug</p>
<h3 id="10-什么情况下用ET模式"><a href="#10-什么情况下用ET模式" class="headerlink" title="10 什么情况下用ET模式"></a>10 什么情况下用ET模式</h3><p>在eventloop类型(包括各类fiber&#x2F;coroutine)的程序中, 处理逻辑和epoll_wait都在一个线程, ET相比LT没有太大的差别。反而由于LT醒的更频繁, 可能时效性更好些。但在更高并发的RPC实现中, 为了对大消息的反序列化也可以并行, 消息的读取和分割可能运行和epoll_wait不同的线程中, 这时ET是必须的, 否则在读完数据前, epoll_wait会不停地无谓醒来。   </p>
<h3 id="11-如果内核写缓冲区充足，epoll的LT模式会反复的触发可写事件，怎么解决"><a href="#11-如果内核写缓冲区充足，epoll的LT模式会反复的触发可写事件，怎么解决" class="headerlink" title="11 如果内核写缓冲区充足，epoll的LT模式会反复的触发可写事件，怎么解决"></a>11 如果内核写缓冲区充足，epoll的LT模式会反复的触发可写事件，怎么解决</h3><p>先不关注可写事件，有数据写直接往socket写，如果没写完，把没写完的数据放到应用层缓冲区，然后关注可写事件。</p>
<blockquote>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Maarten/p/15313801.html">详解Reactor模型 - 清烟无瘾 - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/430986475">【死磕 NIO】— Proactor模式是什么？很牛逼吗？ - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37299596/article/details/107435465">(58条消息) muduo net库学习笔记3——定时器的实现_听说西佳佳难得很的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2854e7e99031">muduo源码学习(三) 定时器实现 - 简书 (jianshu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/qldabiaoge/p/12697439.html">muduo源码分析之定时器TimerQueue - Fitz~ - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hdadiao/article/details/104999203">(58条消息) muduo库学习笔记-线程安全_张火油的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dongfuye/article/details/50880251">(58条消息) epoll LT&#x2F;ET 深入剖析_dongfuye的博客-CSDN博客</a></p>
</blockquote>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/C/">C++</a><a class="link-muted mr-2" rel="tag" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a><a class="link-muted mr-2" rel="tag" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a><a class="link-muted mr-2" rel="tag" href="/tags/%E7%BD%91%E7%BB%9C%E5%BA%93/">网络库</a><a class="link-muted mr-2" rel="tag" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/">服务器</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2023/04/24/CMake%E5%AD%A6%E4%B9%A0/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">CMake学习</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2023/04/22/myMuduo%E5%9B%9E%E9%A1%BE%E4%B8%80%EF%BC%9A%E7%BB%84%E4%BB%B6%E4%B8%8E%E6%95%B4%E4%BD%93%E9%80%BB%E8%BE%91/"><span class="level-item">myMuduo回顾一：组件与整体逻辑</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="MK"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">MK</p><p class="is-size-6 is-block">MKMQ99</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shanghai</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">13</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">8</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">20</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/MKMQ99" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/MKMQ99"><i class="fab fa-github"></i></a></div></div></div><div class="card widget is-sticky" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#1-epoll的具体使用"><span class="level-left"><span class="level-item">1</span><span class="level-item">1 epoll的具体使用</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-1-创建epoll"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">1.1 创建epoll</span></span></a></li><li><a class="level is-mobile" href="#1-2-设置epoll事件"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">1.2 设置epoll事件</span></span></a></li><li><a class="level is-mobile" href="#1-3-等待epoll事件"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">1.3 等待epoll事件</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-常见并发模型"><span class="level-left"><span class="level-item">2</span><span class="level-item">2 常见并发模型</span></span></a></li><li><a class="level is-mobile" href="#3-Reactor和Proactor模型"><span class="level-left"><span class="level-item">3</span><span class="level-item">3 Reactor和Proactor模型</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-1-Reactor-模型"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">3.1 Reactor 模型</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-1-1-单Reactor单线程"><span class="level-left"><span class="level-item">3.1.1</span><span class="level-item">3.1.1 单Reactor单线程</span></span></a></li><li><a class="level is-mobile" href="#3-1-2-单Reactor多线程"><span class="level-left"><span class="level-item">3.1.2</span><span class="level-item">3.1.2 单Reactor多线程</span></span></a></li><li><a class="level is-mobile" href="#3-1-3-主从Reactor多线程"><span class="level-left"><span class="level-item">3.1.3</span><span class="level-item">3.1.3 主从Reactor多线程</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-2-Proactor模型"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">3.2 Proactor模型</span></span></a></li><li><a class="level is-mobile" href="#3-3-两者的区别"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">3.3 两者的区别</span></span></a></li></ul></li><li><a class="level is-mobile" href="#4-muduo的主线程accept的fd如何分发给其他线程？"><span class="level-left"><span class="level-item">4</span><span class="level-item">4 muduo的主线程accept的fd如何分发给其他线程？</span></span></a></li><li><a class="level is-mobile" href="#5-muduo定时器的实现"><span class="level-left"><span class="level-item">5</span><span class="level-item">5 muduo定时器的实现</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#5-1-定时任务的原理"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">5.1 定时任务的原理</span></span></a></li><li><a class="level is-mobile" href="#5-2-muduo定时器涉及的类"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">5.2 muduo定时器涉及的类</span></span></a></li><li><a class="level is-mobile" href="#5-3-Timer类"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">5.3 Timer类</span></span></a></li><li><a class="level is-mobile" href="#5-4-TimerId类"><span class="level-left"><span class="level-item">5.4</span><span class="level-item">5.4 TimerId类</span></span></a></li><li><a class="level is-mobile" href="#5-5-TimerQueue类"><span class="level-left"><span class="level-item">5.5</span><span class="level-item">5.5 TimerQueue类</span></span></a></li></ul></li><li><a class="level is-mobile" href="#6-多线程情况下如何做到线程安全的对象生命期管理"><span class="level-left"><span class="level-item">6</span><span class="level-item">6 多线程情况下如何做到线程安全的对象生命期管理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#6-1-对象构造"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">6.1 对象构造</span></span></a></li><li><a class="level is-mobile" href="#6-2-连接更新、析构等操作"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">6.2 连接更新、析构等操作</span></span></a></li></ul></li><li><a class="level is-mobile" href="#7-muduo如何限制连接的数量？"><span class="level-left"><span class="level-item">7</span><span class="level-item">7 muduo如何限制连接的数量？</span></span></a></li><li><a class="level is-mobile" href="#8-muduo为什么用LT模式"><span class="level-left"><span class="level-item">8</span><span class="level-item">8 muduo为什么用LT模式</span></span></a></li><li><a class="level is-mobile" href="#9-LT模式和ET模式剖析"><span class="level-left"><span class="level-item">9</span><span class="level-item">9 LT模式和ET模式剖析</span></span></a></li><li><a class="level is-mobile" href="#10-什么情况下用ET模式"><span class="level-left"><span class="level-item">10</span><span class="level-item">10 什么情况下用ET模式</span></span></a></li><li><a class="level is-mobile" href="#11-如果内核写缓冲区充足，epoll的LT模式会反复的触发可写事件，怎么解决"><span class="level-left"><span class="level-item">11</span><span class="level-item">11 如果内核写缓冲区充足，epoll的LT模式会反复的触发可写事件，怎么解决</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/C-Tools/"><span class="level-start"><span class="level-item">C++ Tools</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><span class="level-start"><span class="level-item">并发编程</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">数据结构与算法</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"><span class="level-start"><span class="level-item">服务器</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%9D%82%E9%A1%B9/"><span class="level-start"><span class="level-item">杂项</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">计算机网络</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-24T06:20:01.000Z">2023-04-24</time></p><p class="title"><a href="/2023/04/24/CMake%E5%AD%A6%E4%B9%A0/">CMake学习</a></p><p class="categories"><a href="/categories/C-Tools/">C++ Tools</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-22T13:23:33.000Z">2023-04-22</time></p><p class="title"><a href="/2023/04/22/myMuduo%E5%9B%9E%E9%A1%BE%E4%BA%8C%EF%BC%9A%E5%85%B6%E4%BB%96%E9%83%A8%E5%88%86/">myMuduo回顾二：其他部分</a></p><p class="categories"><a href="/categories/C/">C++</a> / <a href="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/">服务器</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-22T13:15:01.000Z">2023-04-22</time></p><p class="title"><a href="/2023/04/22/myMuduo%E5%9B%9E%E9%A1%BE%E4%B8%80%EF%BC%9A%E7%BB%84%E4%BB%B6%E4%B8%8E%E6%95%B4%E4%BD%93%E9%80%BB%E8%BE%91/">myMuduo回顾一：组件与整体逻辑</a></p><p class="categories"><a href="/categories/C/">C++</a> / <a href="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/">服务器</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-18T11:58:03.000Z">2023-04-18</time></p><p class="title"><a href="/2023/04/18/%E6%97%A0%E9%94%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88-C/">无锁数据结构-栈(C++)</a></p><p class="categories"><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a> / <a href="/categories/C/">C++</a> / <a href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-18T06:06:24.000Z">2023-04-18</time></p><p class="title"><a href="/2023/04/18/%E5%9F%BA%E4%BA%8E%E9%94%81%E7%9A%84%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C/">基于锁的并发数据结构(C++)</a></p><p class="categories"><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a> / <a href="/categories/C/">C++</a> / <a href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li></ul></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">MK&#039;s Blog</a><p class="is-size-7"><span>&copy; 2023 MK</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>