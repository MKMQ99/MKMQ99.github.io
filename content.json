{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/04/03/hello-world/"},{"title":"GDB学习","text":"1 调试入门及基础篇1-1 Linux C/C++调试准备工作Ubuntu: apt install gcc g++ make gdb 123456789101112#include&lt;iostream&gt;int main(int argc,char**argv){ int itest=100; const char *str=&quot;this is a test&quot;; std::cout &lt;&lt; &quot;itest is &quot; &lt;&lt; itest &lt;&lt; &quot;,str is &quot; &lt;&lt; str &lt;&lt; std::endl; std::cout &lt;&lt; &quot;参数为:&quot; &lt;&lt; std::endl; for (int i = 0; i &lt; argc; i++){ std::cout &lt;&lt; argv[i] &lt;&lt; std::endl; } std::cout &lt;&lt; &quot;Hello world\\n&quot;; return 0;} 生成可调试的代码：g++ -g test.cpp -o test 进行调试：gdb test list：显示源码，一次默认显示10行 break/b：插入断点 info/i：查看信息 run/r：执行程序 next/n：执行一步 print/p：查看变量名 locals：看局部变量 continue/c：继续执行，直到下一个断点 1-2 启动调试1-2-1 启动调试并传入参数 gdb –args &lt;exe&gt; set args &lt;args&gt; r &lt;args&gt; gdb –args &lt;exe&gt; set args &lt;args&gt; r &lt;args&gt; 1-2-2 附加到进程，适用于已经启动的程序 gdb attach &lt;pid&gt; gdb –pid &lt;pid&gt; gdb attach &lt;pid&gt; gdb –pid &lt;pid&gt; 1-2-3 逐过程执行单步执行（step-over），遇到函数跳过函数 next/n 1-2-4 逐语句执行单步执行（step-into），遇到函数进入函数 step/s 1-2-5 退出当前函数finish 1-2-6 退出调试detach（分离） quit/q（退出） 1-3 调试断点管理1-3-1 设置断点 break/b 文件名:行号，在源代码某一行设置断点 b 函数名：为函数设置断点，同名函数会怎么样？（都添加断点） rb 正则表达式：为满足正则表达式的函数设置断点 b 断点条件：设置条件断点 tb 断点：设置临时断点（只命中一次） 1-3-2 查看/禁用/删除断点 i b：查看所有断点 disable/enable 断点编号：禁用，启用断点 delete 断点：删除断点 1-4 变量查看与修改1-4-1 变量查看 info args：查看函数参数 print/p 变量名：查看变量的值 set print null-stop：设置字符串的显示规则 set print pretty：显示结构体 set print array on：显示数组 使用gdb内嵌函数，比如sizeof,strlen,strcmp等 info args &amp;&amp; print/p 变量名 set print null-stop set print pretty set print array on 使用gdb内嵌函数 1-4-2 变量更改 p 变量=修改值：包括普通变量，结构体，类等 1-5 内存查看与修改1-5-1 内存查看 x /选项 内存地址 x /s str x /d x /4d x /16s 结构体变量地址 1-5-2 内存修改 set 地址=修改值 1-6 寄存器查看与修改1-6-1 查看寄存器 i registers i r rdi … 6个参数以内放寄存器，多的放栈 寄存器 函数参数 rdi 第一个参数 rsi 第二个参数 rdx 第三个参数 rcx 第四个参数 r8 第五个参数 r9 第六个参数 1-6-2 修改寄存器pc/rip (problem counter)寄存器，保存程序下一条要执行的指令，通过修改pc寄存器来改变程序执行的流程 set var $pc=xxx p $rip=xxx info line 行数：查看汇编代码地址 1-7 源代码管理、查看、搜索1-7-1 源代码管理 list/l：显示源代码，默认显示10行（l - ：向前显示） set listsize xx：设置每次显示的行数 list test_fun：查看指定函数代码 list main.cpp:15：查看指定文件指定行代码 1-7-2 搜索源代码 search 正则表达式 forward-search 正则表达式 reverse-search 正则表达式 1-7-3 设置源代码搜索目录show directories：查看当前搜索目录 directory path：添加源代码搜索目录 1-8 函数调用栈管理1-8-1 调用栈管理 backtrace/bt：查看栈回溯信息 frame/f n：切换栈帧 info f n(第几号栈帧)：查看栈帧信息 2 调试中级篇2-1 观察点使用观察点是一个特殊的断点，当表达式的值发生变化时它将中断下来。表达式可以是一个变量的值，也可以包含由运算符组合的一个或多个变量的值，例如a + b。有时被称为数据断点(VC里面就称之为数据断点) watch：写观察点，写变量的时候停下来，hardware watchpoint，不影响性能 rwatch：读观察点 awatch：读写观察点 info watch：查看观察点 delete/disable/enable：删除/禁用/启用观察点 表达式例子： 可指定线程：watch 变量名/表达式 thread 线程号 2-2 捕获点使用捕获点是一个特殊的断点，命令语法为：catch event即捕获到event这个事件的时候，程序就会中断下来 catch assert – Catch failed Ada assertions, when raised. catch catch – Catch an exception, when caught. catch exception – Catch Ada exceptions, when raised. catch exec – Catch calls to exec. catch fork – Catch calls to fork. catch handlers – Catch Ada exceptions, when handled. catch load – Catch loads of shared libraries. catch rethrow – Catch an exception, when rethrown. catch signal - Catch signals by their names and/or numbers. catch syscall – Catch system calls by their names, groups and/ornumbers. catch throw – Catch an exception, when thrown. catch unload – Catch unloads of shared libraries. catch vfork – Catch calls to vfork. 2-3 为断点执行命令1234commands 断点号xxxxxxend 不必每次在断点停下来的时候手动查看值 要删除的话直接commands不输入命令： 12commands 断点号end 导出断点信息：save breakpoints 文件名 加载断点信息：source 文件名 2-4 gdb多窗口管理Text User Interface（TUI） layout src：显示源码窗口 layout asm：显示汇编窗口 layout reg：显示寄存器窗口 layout split：切分窗口 focus/fs src/arm/reg：切换窗口焦点 info win：查看当前拥有焦点的窗口 ctrl+x+a：退出窗口模式 2-5 查看对象类型查看结构体，类，派生类等 whatis ptype /r /o /m /t i variables set print object on 2-6 多线程调试管理 info threads：查看所有线程信息 thread find 地址/LWP/线程名（正则表达式)：查找线程 thread num：切换线程 thread name：设置当前线程名字 b 断点地址 thread id：为线程设置断点 thread apply (多个)线程号 gdb命令：为线程执行命令（避免了切换线程） set print thread-events on|off：设置是否打印线程日志 2-7 执行外部命令以及保存命令及输出 shell/!：执行shell命令 pipe/| gdb命令 | grep 条件：对gdb输出进行筛选 set logging on/off：启用/禁用结果输出 set logging file filename：设置输出文件 set logging overwrite：覆盖输出文件，默认为追加 3 调试高级篇3-1 跳转执行-任意执行代码 jump/j location：即在指定位置恢复执行，如果存在断点，执行到指定位置时将中断下来。如果没有断点，则不会停下来，因此，我们通常会在指定位置设置一个断点。跳转命令不会更改当前堆栈帧、堆栈指针、程序计数器以外的任何寄存器。 3-2 反向执行-调试中的undo record：进行记录 reverse-next：反向运行到上一次被执行的源代码行，但是不进入函数 reverse-finish：反向运行程序回到调用当前函数的地方 record-stop：结束记录 不能用于IO操作 3-3 调试子进程 set follow-fork-mode child/parent：选择调试父进程还是子进程，默认父进程 set detach-on-fork off/on i inferiors：查看进程信息 inferiors n：切换进程 follow-fork-mode detach-on-fork 说明 parent on 只调试主进程( GDB 默认) child on 只调试子进程 parent off 同时调试两个进程, gdb 跟主进程, 子进程 block 在 fork 位置 child off 同时调试两个进程, gdb 跟子进程, 主进程 block 在 fork 位置 3-4 多进程调试先要将进程都attach进来 attach pid set schedule-multiple on detach inferior n 3-5 调试时调用内部、外部函数p表达式：求表达式的值并显示结果值。表达式可以包括对正在调试的程序中的函数的调用，即使函数返回值是void，也会显示。 call 表达式：求表达式的值并显示结果值，如果是函数调用，返回值是void的话，不显示void返回值。 3-6 调试时跳过指定函数指用step不会进入函数 skip 函数名 skip file 文件名：文件中的函数都会被跳过 skip -gfi 通配符：跳过满足通配符的文件 3-7 制作、调试发行版 去掉 -g 参数进行make（自己需要保留有调试信息的版本，所以要make两次） make Debug版本，然后使用 strip -g release-section -o release 命令去掉调试信息（只要make一次） gdb –symbol=release-section -exec=release objcopy –only-keep-debug release-section debug.sym：生成只有调试信息的文件，然后 gdb –symbol=debug.sym -exec=release gdb调试release版core dump文件：gdb release-section rel.core 3-8 软件补丁制作-直接编辑二进制程序 gdb –write 可执行文件：修改可执行文件 disassemble查看反汇编代码，例：disassemble /mr check_some p或者set修改机器码，例：set {unsigned char}0x00000000000011b4=101 4 调试实战篇4-1 内存泄漏检测 call malloc_stats() call malloc_info(0,stdout) 4-2 gcc检测各种内存问题检查：泄漏，栈溢出，野指针等gcc选项 -fsanitize=address检查内存泄漏检查堆溢出检查栈溢出检查全局内存溢出检查释放后再使用 4-3 远程调试1.服务器端/被调试机：安装 gdb server：apt install gdbserver 启动 gdbserver 2.客户端/调试机gdb远程连接并进行调试 4-4 多线程死锁调试分析死锁最常用的命令：thread、bt、f、p等 死锁的条件： 互斥条件 保持和请求条件 不可剥夺条件 循环等待条件 解决死锁的方式： 顺序使用锁 控制锁的作用范围 可以使用超时机制 4-5 核心转储（core dump）基础​ Linux core dump：一般称之为核心转储、内核转储，我们统称为转储文件是某个时刻某个进程的内存信息映射，即包含了生成转储文件时该进程的整个内存信息以及寄存器等信息。转储文件可以是某个进程的，也可以是整个系统的。可以是进程活着的时候生成的，也可以是进程或者系统崩溃的时候自动生成的。​ 为活着的进程创建core dump文件一般可以通过gdb来生成，使用gdb把进程attach进来以后，执行generate-core-file或者gcore命今来生成core dump文件。​ 我们更多时候是对崩溃产生的core dump文件进行分析。 ​ 崩溃时自动生成core文件，需要将 ulimit -c 设置为 unlimted，文件名由/proc/sys/kernel/core_pattern决定 ​ 查看问题：gdb 可执行文件 core文件 4-6 无调试符号core dump分析不能用p打印变量，但可以查看寄存器，查看内存地址的值","link":"/2023/04/03/GDB%E5%AD%A6%E4%B9%A0/"}],"tags":[],"categories":[],"pages":[]}