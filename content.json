{"posts":[{"title":"GDB学习","text":"1 调试入门及基础篇1-1 Linux C/C++调试准备工作Ubuntu: apt install gcc g++ make gdb 123456789101112#include&lt;iostream&gt;int main(int argc,char**argv){ int itest=100; const char *str=&quot;this is a test&quot;; std::cout &lt;&lt; &quot;itest is &quot; &lt;&lt; itest &lt;&lt; &quot;,str is &quot; &lt;&lt; str &lt;&lt; std::endl; std::cout &lt;&lt; &quot;参数为:&quot; &lt;&lt; std::endl; for (int i = 0; i &lt; argc; i++){ std::cout &lt;&lt; argv[i] &lt;&lt; std::endl; } std::cout &lt;&lt; &quot;Hello world\\n&quot;; return 0;} 生成可调试的代码：g++ -g test.cpp -o test 进行调试：gdb test list：显示源码，一次默认显示10行 break/b：插入断点 info/i：查看信息 run/r：执行程序 next/n：执行一步 print/p：查看变量名 locals：看局部变量 continue/c：继续执行，直到下一个断点 1-2 启动调试1-2-1 启动调试并传入参数 gdb –args &lt;exe&gt; set args &lt;args&gt; r &lt;args&gt; gdb –args &lt;exe&gt; set args &lt;args&gt; r &lt;args&gt; 1-2-2 附加到进程，适用于已经启动的程序 gdb attach &lt;pid&gt; gdb –pid &lt;pid&gt; gdb attach &lt;pid&gt; gdb –pid &lt;pid&gt; 1-2-3 逐过程执行单步执行（step-over），遇到函数跳过函数 next/n 1-2-4 逐语句执行单步执行（step-into），遇到函数进入函数 step/s 1-2-5 退出当前函数finish 1-2-6 退出调试detach（分离） quit/q（退出） 1-3 调试断点管理1-3-1 设置断点 break/b 文件名:行号，在源代码某一行设置断点 b 函数名：为函数设置断点，同名函数会怎么样？（都添加断点） rb 正则表达式：为满足正则表达式的函数设置断点 b 断点条件：设置条件断点 tb 断点：设置临时断点（只命中一次） 1-3-2 查看/禁用/删除断点 i b：查看所有断点 disable/enable 断点编号：禁用，启用断点 delete 断点：删除断点 1-4 变量查看与修改1-4-1 变量查看 info args：查看函数参数 print/p 变量名：查看变量的值 set print null-stop：设置字符串的显示规则 set print pretty：显示结构体 set print array on：显示数组 使用gdb内嵌函数，比如sizeof,strlen,strcmp等 info args &amp;&amp; print/p 变量名 set print null-stop set print pretty set print array on 使用gdb内嵌函数 1-4-2 变量更改 p 变量=修改值：包括普通变量，结构体，类等 1-5 内存查看与修改1-5-1 内存查看 x /选项 内存地址 x /s str x /d x /4d x /16s 结构体变量地址 1-5-2 内存修改 set 地址=修改值 1-6 寄存器查看与修改1-6-1 查看寄存器 i registers i r rdi … 6个参数以内放寄存器，多的放栈 寄存器 函数参数 rdi 第一个参数 rsi 第二个参数 rdx 第三个参数 rcx 第四个参数 r8 第五个参数 r9 第六个参数 1-6-2 修改寄存器pc/rip (problem counter)寄存器，保存程序下一条要执行的指令，通过修改pc寄存器来改变程序执行的流程 set var $pc=xxx p $rip=xxx info line 行数：查看汇编代码地址 1-7 源代码管理、查看、搜索1-7-1 源代码管理 list/l：显示源代码，默认显示10行（l - ：向前显示） set listsize xx：设置每次显示的行数 list test_fun：查看指定函数代码 list main.cpp:15：查看指定文件指定行代码 1-7-2 搜索源代码 search 正则表达式 forward-search 正则表达式 reverse-search 正则表达式 1-7-3 设置源代码搜索目录show directories：查看当前搜索目录 directory path：添加源代码搜索目录 1-8 函数调用栈管理1-8-1 调用栈管理 backtrace/bt：查看栈回溯信息 frame/f n：切换栈帧 info f n(第几号栈帧)：查看栈帧信息 2 调试中级篇2-1 观察点使用观察点是一个特殊的断点，当表达式的值发生变化时它将中断下来。表达式可以是一个变量的值，也可以包含由运算符组合的一个或多个变量的值，例如a + b。有时被称为数据断点(VC里面就称之为数据断点) watch：写观察点，写变量的时候停下来，hardware watchpoint，不影响性能 rwatch：读观察点 awatch：读写观察点 info watch：查看观察点 delete/disable/enable：删除/禁用/启用观察点 表达式例子： 可指定线程：watch 变量名/表达式 thread 线程号 2-2 捕获点使用捕获点是一个特殊的断点，命令语法为：catch event即捕获到event这个事件的时候，程序就会中断下来 catch assert – Catch failed Ada assertions, when raised. catch catch – Catch an exception, when caught. catch exception – Catch Ada exceptions, when raised. catch exec – Catch calls to exec. catch fork – Catch calls to fork. catch handlers – Catch Ada exceptions, when handled. catch load – Catch loads of shared libraries. catch rethrow – Catch an exception, when rethrown. catch signal - Catch signals by their names and/or numbers. catch syscall – Catch system calls by their names, groups and/ornumbers. catch throw – Catch an exception, when thrown. catch unload – Catch unloads of shared libraries. catch vfork – Catch calls to vfork. 2-3 为断点执行命令1234commands 断点号xxxxxxend 不必每次在断点停下来的时候手动查看值 要删除的话直接commands不输入命令： 12commands 断点号end 导出断点信息：save breakpoints 文件名 加载断点信息：source 文件名 2-4 gdb多窗口管理Text User Interface（TUI） layout src：显示源码窗口 layout asm：显示汇编窗口 layout reg：显示寄存器窗口 layout split：切分窗口 focus/fs src/arm/reg：切换窗口焦点 info win：查看当前拥有焦点的窗口 ctrl+x+a：退出窗口模式 2-5 查看对象类型查看结构体，类，派生类等 whatis ptype /r /o /m /t i variables set print object on 2-6 多线程调试管理 info threads：查看所有线程信息 thread find 地址/LWP/线程名（正则表达式)：查找线程 thread num：切换线程 thread name：设置当前线程名字 b 断点地址 thread id：为线程设置断点 thread apply (多个)线程号 gdb命令：为线程执行命令（避免了切换线程） set print thread-events on|off：设置是否打印线程日志 2-7 执行外部命令以及保存命令及输出 shell/!：执行shell命令 pipe/| gdb命令 | grep 条件：对gdb输出进行筛选 set logging on/off：启用/禁用结果输出 set logging file filename：设置输出文件 set logging overwrite：覆盖输出文件，默认为追加 3 调试高级篇3-1 跳转执行-任意执行代码 jump/j location：即在指定位置恢复执行，如果存在断点，执行到指定位置时将中断下来。如果没有断点，则不会停下来，因此，我们通常会在指定位置设置一个断点。跳转命令不会更改当前堆栈帧、堆栈指针、程序计数器以外的任何寄存器。 3-2 反向执行-调试中的undo record：进行记录 reverse-next：反向运行到上一次被执行的源代码行，但是不进入函数 reverse-finish：反向运行程序回到调用当前函数的地方 record-stop：结束记录 不能用于IO操作 3-3 调试子进程 set follow-fork-mode child/parent：选择调试父进程还是子进程，默认父进程 set detach-on-fork off/on i inferiors：查看进程信息 inferiors n：切换进程 follow-fork-mode detach-on-fork 说明 parent on 只调试主进程( GDB 默认) child on 只调试子进程 parent off 同时调试两个进程, gdb 跟主进程, 子进程 block 在 fork 位置 child off 同时调试两个进程, gdb 跟子进程, 主进程 block 在 fork 位置 3-4 多进程调试先要将进程都attach进来 attach pid set schedule-multiple on detach inferior n 3-5 调试时调用内部、外部函数p表达式：求表达式的值并显示结果值。表达式可以包括对正在调试的程序中的函数的调用，即使函数返回值是void，也会显示。 call 表达式：求表达式的值并显示结果值，如果是函数调用，返回值是void的话，不显示void返回值。 3-6 调试时跳过指定函数指用step不会进入函数 skip 函数名 skip file 文件名：文件中的函数都会被跳过 skip -gfi 通配符：跳过满足通配符的文件 3-7 制作、调试发行版 去掉 -g 参数进行make（自己需要保留有调试信息的版本，所以要make两次） make Debug版本，然后使用 strip -g release-section -o release 命令去掉调试信息（只要make一次） gdb –symbol=release-section -exec=release objcopy –only-keep-debug release-section debug.sym：生成只有调试信息的文件，然后 gdb –symbol=debug.sym -exec=release gdb调试release版core dump文件：gdb release-section rel.core 3-8 软件补丁制作-直接编辑二进制程序 gdb –write 可执行文件：修改可执行文件 disassemble查看反汇编代码，例：disassemble /mr check_some p或者set修改机器码，例：set {unsigned char}0x00000000000011b4=101 4 调试实战篇4-1 内存泄漏检测 call malloc_stats() call malloc_info(0,stdout) 4-2 gcc检测各种内存问题检查：泄漏，栈溢出，野指针等gcc选项 -fsanitize=address检查内存泄漏检查堆溢出检查栈溢出检查全局内存溢出检查释放后再使用 4-3 远程调试1.服务器端/被调试机：安装 gdb server：apt install gdbserver 启动 gdbserver 2.客户端/调试机gdb远程连接并进行调试 4-4 多线程死锁调试分析死锁最常用的命令：thread、bt、f、p等 死锁的条件： 互斥条件 保持和请求条件 不可剥夺条件 循环等待条件 解决死锁的方式： 顺序使用锁 控制锁的作用范围 可以使用超时机制 4-5 核心转储（core dump）基础​ Linux core dump：一般称之为核心转储、内核转储，我们统称为转储文件是某个时刻某个进程的内存信息映射，即包含了生成转储文件时该进程的整个内存信息以及寄存器等信息。转储文件可以是某个进程的，也可以是整个系统的。可以是进程活着的时候生成的，也可以是进程或者系统崩溃的时候自动生成的。​ 为活着的进程创建core dump文件一般可以通过gdb来生成，使用gdb把进程attach进来以后，执行generate-core-file或者gcore命今来生成core dump文件。​ 我们更多时候是对崩溃产生的core dump文件进行分析。 ​ 崩溃时自动生成core文件，需要将 ulimit -c 设置为 unlimted，文件名由/proc/sys/kernel/core_pattern决定 ​ 查看问题：gdb 可执行文件 core文件 4-6 无调试符号core dump分析不能用p打印变量，但可以查看寄存器，查看内存地址的值 参考：SimpleSoft-2020/gdbdebug: gdb debug example (github.com)","link":"/2023/04/03/GDB%E5%AD%A6%E4%B9%A0/"},{"title":"MySQL事务基础与实现原理","text":"1 事务的基本概念事务一般指的是逻辑上的一组操作，或者作为单个逻辑单元执行的一系列操作。同属于一个事务的操作会作为一个整体提交给系统，这些操作要么全部执行成功，要么全部执行失败。 总体来说，事务存在四大特性（ACID），分别是原子性（Atomic）、一致性（Consistency）、隔离性 （Isolation）和持久性（Durability）。 原子性：构成事务的所有操作要么全部执行成功，要么全部执行失败，不可能出现部分执行成功，部分执行失败的情况。 一致性：在事务执行之前和执行之后，数据始终处于一致的状态。 隔离性：并发执行的两个事务之间互不干扰。MySQL 通过锁和 MVCC 机制来保证事务的隔离性。 持久性：是事务提交完成后，此事务对数据的更改操作会被持久化到数据库中，并且不会被回滚。 2 MySQL事务基础2.1 并发事务带来的问题 2.1.1 更新丢失（脏写）当两个或两个以上的事务选择数据库中的同一行数据，并基于最初选定的值更新该行数据时，因为每个事务之间都无法感知彼此的存在，所以会出现最后的更新操作覆盖之前由其他事务完成的更新操作的情况。也就是说，对于同一行数据，一个事务对该行数据的更新操作覆盖了其他事务对该行数据的更新操作。 例如，张三的账户余额是100元，当前有事务A和事务B两个事务，事务A是将张三的账户余额 增加100元，事务B是将张三的账户余额增加200元。起初，事务A和事务B同时读取到张三的账 户余额为100元。然后，事务A和事务B将分别更新张三的银行账户余额，假设事务A先于事务B提交，但事务A和事务B都提交后的结果是张三的账户余额是300元。也就是说，后提交的事务B覆盖了事务A的更新操作。 更新丢失（脏写）本质上是写操作的冲突，解决办法是让每个事务按照串行的方式执行，按照一定的顺序依次进行写操作。 2.1.2 脏读一个事务正在对数据库中的一条记录进行修改操作，在这个事务完成并提交之前，当有另一个事务来读取正在修改的这条数据记录时，如果没有对这两个事务进行控制，则第二个事务就会读取到没有被提交的脏数据，并根据这些脏数据做进一步的处理，此时就会产生未提交的数据依赖关系。我们通常把这种现象称为脏读，也就是一个事务读取了另一个事务未提交的数据。 例如，当前有事务A和事务B两个事务，事务A是向张三的银行账户转账100元，事务B是查询张三的账户余额。事务A执行转账操作，在事务A未提交时，事务B查询到张三的银行账户多了100元，后来事务A由于某些原因，例如服务超时、系统异常等因素进行回滚操作，但事务B查询到的数据并没有改变。此时，事务B查询到的数据就是脏数据。 脏读本质上是读写操作的冲突，解决办法是先写后读，也就是写完之后再读。 2.1.3 不可重复读一个事务读取了某些数据，在一段时间后，这个事务再次读取之前读过的数据，此时发现读取的数据发生了变化，或者其中的某些记录已经被删除，这种现象就叫作不可重复读。即同一个事务，使用相同的查询语句，在不同时刻读取到的结果不一致。 例如，当前有事务A和事务B两个事务，事务A是向张三的银行账户转账100元，事务B是查询张三的账户余额。第一次查询时，事务A还没有转账，第二次查询时，事务A已经转账成功，此 时，就会导致事务B两次查询结果不一致。 不可重复读本质上也是读写操作的冲突，解决办法是先读后写，也就是读完之后再写。 2.1.4 幻读一个事务按照相同的查询条件重新读取之前读过的数据，此时发现其他事务插入了满足当前事务查询条件的新数据，这种现象叫作幻读。即一个事务两次读取一个范围的数据记录，两次读取到的结果不同。 例如，当前有事务A和事务B两个事务，事务A是两次查询张三的转账记录，事务B是向张三的银行账户转账100元。事务A第一次查询时，事务B还没有转账，事务A第二次查询时，事务B已 经转账成功，此时，就会导致事务A两次查询的转账数据不一致。 幻读本质上是读写操作的冲突，解决办法是先读后写，也就是读完之后再写。 2.1.5 不可重复读与幻读的区别 不可重复读的重点在于更新和删除操作，而幻读的重点在于插入操作 幻读无法通过行级锁来避免，需要使用串行化的事务隔离级别，但是这种事务隔离级别会极大降低数据库的并发能力。 从本质上讲，不可重复读和幻读最大的区别在于如何通过锁机制解决问题。 另外，除了可以使用悲观锁来避免不可重复读和幻读的问题外，我们也可以使用乐观锁来处理，例如，MySQL、Oracle和PostgreSQL等数据库为了提高整体性能，就使用了基于乐观锁的MVCC（多版本并发控制）机制来避免不可重复读和幻读。 2.2 MySQL事务隔离级别MySQL中的InnoDB储存引擎提供 SQL标准所描述的4种事务隔离级别，分别为读未提交（Read Uncommitted）、读已提交 （Read Committed）、可重复读（Repeatable Read）和串行化（Serializable）。MySQL中的InnoDB默认为可重复读。Oracle默认为读已提交。 事务隔离级别 脏读 不可重复读 幻读 读未提交 可能 可能 可能 读已提交 不可能 可能 可能 可重复读 不可能 不可能 可能 串行化 不可能 不可能 不可能 2.3 MySQL中锁的分类 Some Tips 实现乐观锁的一种常用做法是为数据增加一个版本标识，如果是通过数据库实现，往往会在数据表中增加一个类似version的版本号字段。在查询数据表中的数据时，会将版本号字段的值一起读取出来，当更新数据时，会令版本号字段的值加1。将提交数据的版本与数据表对应记录的版本进行对比，如果提交的数据版本号大于数据表中当前要修改的数据的版本号，则对数据进行修改操作。否则，不修改数据表中的数据。 表锁开销比较小， 加锁速度快，一般不会出现死锁，锁定的粒度比较大，发生锁冲突的概率最高，并发度最低。行锁开销比较大，加锁速度慢，可能会出现死锁，锁定的粒度最小，发生锁冲突的概率最小，并发度最高。页面锁对数据的加锁开销介于表锁和行锁之间，可能会出现死锁，锁定的粒度大小介于表锁和行锁之间，并发度一般。 行锁主要加在索引上，如果对非索引的字段设置条件进行更新，行锁可能会变成表锁。 InnoDB的行锁是针对索引加锁，不是针对记录加锁，并且加锁的索引不能失效，否则行锁可能会变成表锁。 间隙锁只有在可重复读事务隔离级别下才会生效 2.4 MySQL中如何避免死锁 尽量让数据表中的数据检索都通过索引来完成，避免无效索引导致行锁升级为表锁。 合理设计索引，尽量缩小锁的范围。 尽量减少查询条件的范围，尽量避免间隙锁或缩小间隙锁的范围。 尽量控制事务的大小，减少一次事务锁定的资源数量，缩短锁定资源的时间。 如果一条SQL语句涉及事务加锁操作，则尽量将其放在整个事务的最后执行。 尽可能使用低级别的事务隔离机制。 3 MySQL事务实现原理从某种程度上说，事务的隔离性是由锁和 MVCC 机制实现的，原⼦性和持久性是由Redo Log实现的，一致性是由Undo Log实现的。 3.1 Redo LogRedo Log 确保MySQL事务提交后，事务所涉及的所有操作要么全部执行成功，要么全部执行失败。 3.1.1 Redo Log 基本原理Redo Log也被称作重做日志，它是在InnoDB存储引擎中产生的，用来保证事务的原⼦性和持 久性。Redo Log主要记录的是物理日志，也就是对磁盘上的数据进行的修改操作。Redo Log 往往用来恢复提交后的物理数据页，不过只能恢复到最后一次提交的位置。 Redo Log通常包含两部分：一部分是内存中的日志缓冲，称作Redo Log Buffer，这部分日志比较容易丢失；另一份是存放在磁盘上的重做日志文件，称作Redo Log File，这部分日志是持久化到磁盘上的，不容易丢失。 3.1.2 Redo Log 刷盘规则 在InnoDB存储引擎中，Redo Log具有以下几种刷盘规则。 开启事务，发出提交事务指令后是否刷新日志由变量innodb_flush_log_at_trx_commit决定 每秒刷新一次，刷新日志的频率由变量innodb_flush_log_at_timeout的值决定，默认是1s。 需要注意的是，刷新日志的频率和是否行了commit操作无关 当Log Buffer中已经使用的内存超过一半时，也会触发刷盘操作 对于第一条规则，在进行一定的说明。当事务提交时，需要先将事务日志写入Log Buffer，这些写入Log Buffer的日志并不是随着事务 的提交立刻写入磁盘的，而是根据一定的规则将Log Buffer中的数据刷写到磁盘，从而保证了 Redo Log文件中数据的持久性。这种刷盘规则可以通过innodb_flush_log_at_trx_commit变量 控制，innodb_flush_log_at_trx_commit变量可取的值有0、1和2，默认为1。 如果该变量设置为0，则每次提交事务时，不会将Log Buffer中的日志写入OS Buffer，而是通 过一个单独的线程，每秒写入OS Buffer并调用fsync()函数写入磁盘的Redo Log文件。这种方式不是实时写磁盘的，而是每隔1s写一次日志，如果系统崩溃，可能会丢失1s的数据 如果该变量设置为1，则每次提交事务都会将Log Buffer中的日志写入OS Buffer，并且会调用 fsync()函数将日志数据写入磁盘的Redo Log文件中。这种方式虽然在系统崩溃时不会丢失数 据，但是性能比较差。如果没有设置innodb_flush_log_at_trx_commit变量的值，则默认为1 如果该变量设置为2，则每次提交事务时，都只是将数据写入OS Buffer，之后每隔1s，通过 fsync()函数将OS Buffer中的日志数据同步写入磁盘的Redo Log文件中。 3.2 Undo LogUndo Log在MySQL事务的实现中主要起到两方面的作用：回滚事务和多版本并发事务，也就是常说的MVCC机制。在MySQL启动事务之前，会先将要修改的数据记录存储到Undo Log中。如果数据库的事务回滚或者MySQL数据库崩溃，可以利用Undo Log对数据库中未提交的事务进行回滚操作，从而保证数据库中数据的一致性。 Undo Log会在事务开始前产生，当事务提交时，并不会立刻删除相应的Undo Log。此时，InnoDB存储引擎会将当前事务对应的Undo Log放入待删除的列表，接下来，通过一个后台线程purge thread进行删除处理。 Undo Log与Redo Log不同，Undo Log记录的是逻辑日志，可以这样理解：当数据库执行一条 insert语句时，Undo Log会记录一条对应的delete语句；当数据库执行一条delete语句时，Undo Log会记录一条对应的insert语句；当数据库执行一条update语句时，Undo Log会记 录一条相反的update语句。 需要注意的是，因为MySQL事务执行过程中产生的Undo Log也需要进行持久化操作，所以 Undo Log也会产生Redo Log。由于Undo Log的完整性和可靠性需要Redo Log来保证，因此数据库崩溃时需要先做Redo Log数据恢复，然后做Undo Log回滚。 3.3 BinLogRedo Log是InnoDB存储引擎特有的日志，MySQL也有其自身的日志，这个日志就是BinLog， 即二进制日志。 3.3.1 BinLog基本概念BinLog是一种记录所有MySQL数据库表结构变更以及表数据变更的二进制日志。BinLog中不会记录诸如select和show这类查询操作的日志，同时，BinLog是以事件形式记录相关变更操作 的，并且包含语句执行所消耗的时间。BinLog有以下两个最重要的使用场景： 主从复制：在主数据库上开启BinLog，主数据库把BinLog发送至从数据库，从数据库获取BinLog后通过I/O线程将日志写到中继日志，也就是Relay Log中。然后，通过SQL线程将 Relay Log中的数据同步至从数据库，从而达到主从数据库数据的一致性。 数据恢复：当MySQL数据库发生故障或者崩溃时，可以通过BinLog进行数据恢复。例如， 可以使用mysqlbinlog等工具进行数据恢复。 3.3.2 BinLog记录模式BinLog文件中主要有3种记录模式，分别为Row、Statement和Mixed Row模式 Row模式下的BinLog文件会记录每一行数据被修改的情况，然后在MySQL从数据库中对相同的数据进行修改。 Row模式的优点是能够非常清楚地记录每一行数据的修改情况，完全实现主从数据库的同步和数据的恢复。 Row模式的缺点是如果主数据库中发生批量操作，尤其是大批量的操作，会产生大量的二进制日志。比如，使用alter table操作修改拥有大量数据的数据表结构时，会使二进制日志的内容暴涨，产生大量的二进制日志，从而大大影响主从数据库的同步性能。 Statement模式 Statement模式下的BinLog文件会记录每一条修改数据的SQL语句，MySQL从数据库在复制 SQL语句的时候，会通过SQL进程将BinLog中的SQL语句解析成和MySQL主数据库上执行过的 SQL语句相同的SQL语句，然后在从数据库上执行SQL进程解析出来的SQL语句。 Statement模式的优点是由于不记录数据的修改细节，只是记录数据表结构和数据变更的SQL 语句，因此产生的二进制日志数据量比较小，这样能够减少磁盘的I/O操作，提升数据存储和恢复的效率。 Statement模式的缺点是在某些情况下，可能会导致主从数据库中的数据不一致。例如，在 MySQL主数据库中使用了last_insert_id()和now()等函数，会导致MySQL主从数据库中的数据不一致。 Mixed模式 Mixed模式下的BinLog是Row模式和Statement模式的混用。在这种模式下，一般会使用 Statement模式保存BinLog，如果存在Statement模式⽆法复制的操作，例如在MySQL主数据库中使用了last_insert_id()和now()等函数，MySQL会使用Row模式保存BinLog。也就是说， 如果将BinLog的记录模式设置为Mixed,MySQL会根据执行的SQL语句选择写入的记录模式。 3.3.3 BinLog和Redo Log的区别 BinLog是MySQL本身就拥有的，不管使用何种存储引擎，BinLog都存在，而Redo Log是 InnoDB存储引擎特有的，只有InnoDB存储引擎才会输出Redo Log。 BinLog是一种逻辑日志，记录的是对数据库的所有修改操作，而Redo Log是一种物理日志，记录的是每个数据页的修改。 Redo Log具有幂等性，多次操作的前后状态是一致的，而BinLog不具有幂等性，记录的是所有影响数据库的操作。例如插入一条数据后再将其删除，则Redo Log前后的状态未发生变化，而BinLog就会记录插入操作和删除操作。 BinLog开启事务时，会将每次提交的事务一次性写入内存缓冲区，如果未开启事务，则每次成功执行插入、更新和删除语句时，就会将对应的事务信息写入内存缓冲区，而Redo Log是 在数据准备修改之前将数据写入缓冲区的Redo Log中，然后在缓冲区中修改数据。而且在提交事务时，先将Redo Log写入缓冲区，写入完成后再提交事务。 BinLog只会在事务提交时，一次性写入BinLog，其日志的记录方式与事务的提交顺序有 关，并且一个事务的BinLog中间不会插入其他事务的BinLog。而Redo Log记录的是物理页的修改，最后一个提交的事务记录会覆盖之前所有未提交的事务记录，并且一个事务的Redo Log 中间会插入其他事务的Redo Log。 BinLog是追加写入，写完一个日志文件再写下一个日志文件，不会覆盖使用，而Redo Log 是循环写入，日志空间的大小是固定的，会覆盖使用。 BinLog一般用于主从复制和数据恢复，并且不具备崩溃自动恢复的能力，而Redo Log是在服务器发生故障后重启MySQL，用于恢复事务已提交但未写入数据表的数据。 参考：深入理解分布式事务：原理与实战","link":"/2023/04/05/MySQL%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/04/03/hello-world/"},{"title":"常用设计模式","text":"1 设计模式的六大原则 SRP（Single Responsibility Principle）：单一职责原则，一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。 OCP（Open Close Principle）：开放封闭原则，软件实体可以扩展，但是不可修改。即面对需求，对程序的改动可以通过增加代码来完成，但是不能改动现有的代码。 LSP（Liskov Substitution Principle）：里氏代换原则，就是基类出现的地方，通过它的子类也完全可以实现这个功能。 DIP（Dependence Inversion Principle）：依赖倒置原则，高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象，其核心思想是：要面向接口编程，不要面向实现编程。 ISP（Interface Segregation Principle）：接口隔离原则，建立一接口，尽量细化接口，接口中的方法尽量少。每个接口中不存在派生类用不到却必须实现的方法，如果不然，就要将接口拆分，使用多个隔离的接口。 CRP（Composite Reuse Principle）：迪米特原则，如果两个类不直接通信，那么这两个类就不应当发生直接的相互作用。如果一个类需要调用另一个类 的某个方法的话，可以通过第三个类转发这个调用。 2 三类设计模式 创造型模式：单例模式、工厂模式、建造者模式、原型模式 结构型模式：适配器模式、桥接模式、外观模式、组合模式、装饰模式、享元模式、代理模式 行为型模式：责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式、访问者模式 3 常见设计模式3.1 单例模式保证一个类仅有一个实例，并提供一个访问它的全局访问点。 有两种，懒汉和饿汉： 饿汉：饿了就饥不择食了，所以在单例类定义的时候就进行实例化。 懒汉：顾名思义，不到万不得已就不会去实例化类，也就是在第一次用到的类实例的时候才会去实例化。 饿汉模式（线程安全） 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;class SingleInstance{ public: static SingleInstance* GetInstance(){ static SingleInstance ins; return &amp;ins; } ~SingleInstance(){}; private: // 涉及到创建对象的函数都设置为private SingleInstance() { std::cout&lt;&lt;&quot;SingleInstance() 饿汉&quot;&lt;&lt;std::endl; } SingleInstance(const SingleInstance&amp; other) {}; SingleInstance&amp; operator=(const SingleInstance&amp; other) {return *this;}};int main(){ //因为不能创建对象所以通过静态成员函数的⽅法返回静态成员变量 SingleInstance* ins = SingleInstance::GetInstance(); return 0;}//输出 SingleInstance() 饿汉 懒汉模式（线程安全需要加锁） 尽可能的晚的创建这个对象的实例，即在单例类第一次被引用的时候就将自己初始化，C++ 很多地方都有类型的思想，比如写时拷贝，晚绑定等。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;thread&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;class SingleInstance{ public: static SingleInstance* GetInstance(){ if (ins == nullptr){ lock_guard&lt;mutex&gt; lck(mLock); if (ins == nullptr){ ins = new SingleInstance(); } } return ins; } ~SingleInstance(){}; private: //涉及到创建对象的函数都设置为private SingleInstance() { std::cout&lt;&lt;&quot;SingleInstance() 懒汉&quot;&lt;&lt;std::endl; } SingleInstance(const SingleInstance&amp; other) {}; SingleInstance&amp; operator=(const SingleInstance&amp; other) { return *this; } static mutex mLock; static SingleInstance* ins;};//懒汉式 静态变量需要定义SingleInstance* SingleInstance::ins = nullptr;mutex SingleInstance::mLock;int main(){ //因为不能创建对象所以通过静态成员函数的⽅法返回静态成员变ᰁ SingleInstance* ins = SingleInstance::GetInstance(); delete ins; return 0;}//输出 SingleInstance() 懒汉 3.2 工厂模式简单工厂模式： 就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std;// 产品类（抽象类，不能实例化）class Product{ public: Product(){}; virtual void show()=0; //纯虚函数};class productA : public Product{ public: productA(){}; void show(){ std::cout &lt;&lt; &quot;product A create!&quot; &lt;&lt; std::endl; }; ~productA(){};};class productB : public Product{ public: productB(){}; void show(){ std::cout &lt;&lt; &quot;product B create!&quot; &lt;&lt; std::endl; }; ~productB(){};};// 工厂类class simpleFactory{ public: simpleFactory(){}; Product* product(const string str){ if (str == &quot;productA&quot;) return new productA(); if (str == &quot;productB&quot;) return new productB(); return NULL; };};int main(){ simpleFactory obj; // 创建工厂 Product* pro; // 创建产品 pro = obj.product(&quot;productA&quot;); pro-&gt;show(); // product A create! delete pro; pro = obj.product(&quot;productB&quot;); pro-&gt;show(); // product B create! delete pro; return 0;} 工厂模式目的就是代码解耦，如果我们不采用工厂模式，如果要创建产品 A、B，通常做法采用switch…case语 句，那么想后期添加更多的产品进来，我们不是要添加更多的 switch…case 吗？这样就很麻烦，而且也不符合设计模式中的开放封闭原则。 为了进一步解耦，在简单工厂的基础上发展出了抽象工厂模式，即连工厂都抽象出来，实现了进一步代码解耦。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;thread&gt;using namespace std;// 产品类（抽象类，不能实例化）class Product{ public: Product(){}; virtual void show()=0; //纯虚函数};//抽象类class Factory{ public: virtual Product* CreateProduct()=0;//纯虚函数};class productA : public Product{ public: productA(){}; void show(){ std::cout &lt;&lt; &quot;product A create!&quot; &lt;&lt; std::endl; }; ~productA(){};};class productB : public Product{ public: productB(){}; void show(){ std::cout &lt;&lt; &quot;product B create!&quot; &lt;&lt; std::endl; }; ~productB(){};};//⼯⼚类A，只⽣产A产品class FactorA: public Factory{ public: Product* CreateProduct(){ Product* product_ = new ProductA(); return product_; }};//⼯⼚类B，只⽣产B产品class FactorB: public Factory{ public: Product* CreateProduct(){ Product* product_ = new ProductB(); return product_; }};int main(){ Product* product_ = nullptr; auto MyFactoryA = new FactorA(); product_ = MyFactoryA-&gt;CreateProduct();// 调用产品A的⼯⼚来⽣产A产品 product_-&gt;show(); delete product_; auto MyFactoryB=new FactorB(); product_ = MyFactoryB-&gt;CreateProduct();// 调用产品B的⼯⼚来⽣产B产品 product_-&gt;show(); delete product_; return 0;}//输出//product A create! product B create! 3.3 观察者模式定义一种一（被观察类）对多（观察类）的关系，让多个观察对象同时监听一个被观察对象，被观察对象状态发生变化时，会通知所有的观察对象，使他们能够更新自己的状态。 观察者模式中存在两种角色： 观察者：内部包含被观察者对象，当被观察者对象的状态发生变化时，更新自己的状态（接收通知更新状态） 被观察者：内部包含了所有观察者对象，当状态发生变化时通知所有的观察者更新自己的状态（发送通知） 应用场景：当一个对象的改变需要同时改变其他对象，且不知道具体有多少对象有待改变时，应该考虑使用观察者模式；一个抽象模型有两个方面，其中一方面依赖于另一方面，这时可以用观察者模式将这两者封装在独立的对象中使它们各自独立地改变和复用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;list&gt;using namespace std;class Subject;//观察者 基类 （内部实例化了被观察者的对象sub）class Observer { protected: string name; Subject *sub; public: Observer(string name, Subject *sub) { this-&gt;name = name; this-&gt;sub = sub; } virtual void update() = 0;};class StockObserver : public Observer { public: StockObserver(string name, Subject *sub) : Observer(name, sub){} void update();};class NBAObserver : public Observer { public: NBAObserver(string name, Subject *sub) : Observer(name, sub){} void update();};//被观察者基类 （内部存放了所有的观察者对象，以便状态发⽣变化时，给观察者发通知）class Subject { protected: std::list&lt;Observer *&gt; observers; public: string action; //被观察者对象的状态 virtual void attach(Observer *) = 0; virtual void detach(Observer *) = 0; virtual void notify() = 0;};class Secretary : public Subject { void attach(Observer *observer) { observers.push_back(observer); } void detach(Observer *observer) { list&lt;Observer *&gt;::iterator iter = observers.begin(); while (iter != observers.end()) { if ((*iter) == observer) { observers.erase(iter); return; } ++iter; } } void notify() { list&lt;Observer *&gt;::iterator iter = observers.begin(); while (iter != observers.end()) { (*iter)-&gt;update(); ++iter; } }};void StockObserver::update() { cout &lt;&lt; name &lt;&lt; &quot; 收到消息：&quot; &lt;&lt; sub-&gt;action &lt;&lt; endl; if (sub-&gt;action == &quot;⽼板来了!&quot;) { cout &lt;&lt; &quot;我⻢上关闭股票，装做很认真⼯作的样⼦！&quot; &lt;&lt; endl; }}void NBAObserver::update() { cout &lt;&lt; name &lt;&lt; &quot; 收到消息：&quot; &lt;&lt; sub-&gt;action &lt;&lt; endl; if (sub-&gt;action == &quot;⽼板来了!&quot;) { cout &lt;&lt; &quot;我⻢上关闭 NBA，装做很认真⼯作的样⼦！&quot; &lt;&lt; endl; }}int main(){ Subject *BOSS = new Secretary(); Observer *xa = new NBAObserver(&quot;xa&quot;, BOSS); Observer *xb = new NBAObserver(&quot;xb&quot;, BOSS); Observer *xc = new StockObserver(&quot;xc&quot;, BOSS); BOSS-&gt;attach(xa); BOSS-&gt;attach(xb); BOSS-&gt;attach(xc); BOSS-&gt;action = &quot;去吃饭了！&quot;; BOSS-&gt;notify(); cout &lt;&lt; endl; BOSS-&gt;action = &quot;⽼板来了!&quot;; BOSS-&gt;notify(); return 0;} 3.4 装饰器模式装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。 这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。 代码没有改变 Car 类的内部结构，还为其增加了新的功能，这就是装饰器模式的作用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;memory&gt;using namespace std;//抽象构件类 Transform (变形⾦刚)class Transform{ public: virtual void move() = 0;};//具体构件类Carclass Car : public Transform{ public: Car(){ std::cout &lt;&lt; &quot;变形⾦刚是⼀辆⻋！&quot; &lt;&lt; endl; } void move(){ std::cout &lt;&lt; &quot;在陆地上移动。&quot; &lt;&lt; endl; }};//抽象装饰类class Changer : public Transform{ public: Changer(shared_ptr&lt;Transform&gt; transform){ this-&gt;transform = transform; } void move(){ transform-&gt;move(); } private: shared_ptr&lt;Transform&gt; transform;};//具体装饰类Robotclass Robot : public Changer{ public: Robot(shared_ptr&lt;Transform&gt; transform) : Changer(transform){ std::cout &lt;&lt; &quot;变成机器⼈!&quot; &lt;&lt; std::endl; } void say(){ std::cout &lt;&lt; &quot;说话!&quot; &lt;&lt; std::endl; }};//具体装饰类AirPlaneclass Airplane : public Changer{ public: Airplane(shared_ptr&lt;Transform&gt; transform) : Changer(transform){ std::cout &lt;&lt; &quot;变成⻜机!&quot; &lt;&lt; std::endl; } void say(){ std::cout &lt;&lt; &quot;在天空⻜翔!&quot; &lt;&lt; std::endl; } };int main(void){ shared_ptr&lt;Transform&gt; camaro = make_shared&lt;Car&gt;(); camaro-&gt;move(); std::cout &lt;&lt; &quot;--------------&quot; &lt;&lt; endl; shared_ptr&lt;Robot&gt; bumblebee = make_shared&lt;Robot&gt;(camaro); bumblebee-&gt;move(); bumblebee-&gt;say(); return 0;}/*输出变形⾦刚是⼀辆⻋！在陆地上移动。--------------变成机器⼈!在陆地上移动。说话!*/ 参考： 常见C++设计模式面试题和场景题_牛客网 (nowcoder.com) 20 万字的 C++ 八股文&amp;图解源码，发布！ (qq.com)","link":"/2023/04/10/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"title":"常见排序算法","text":"1 常见排序算法及其时间和空间复杂度 排序算法 平均时间复杂度 最好情况 最坏情况 空间复杂度 稳定性 冒泡排序 $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ 稳定 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ 不稳定 插入排序 $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ 稳定 希尔排序 $O(n^\\frac{3}{2})$ $O(nlog2n)$ $O(n^2)$ $O(1)$ 不稳定 归并排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ $O(n)$ 稳定 快速排序 $O(nlogn)$ $O(nlogn)$ $O(n^2)$ $O(logn)$ 不稳定 堆排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ $O(1)$ 不稳定 计数排序 $O(n+k)$ $O(n+k)$ $O(n+k)$ $O(k)$ 稳定 桶排序 $O(n+k)$ $O(n+k)$ $O(n^2)$ $O(n+k)$ 稳定 基数排序 $O(n\\times k)$ $O(n\\times k)$ $O(n\\times k)$ $O(n+k)$ 稳定 2 冒泡排序算法描述：比较相邻的元素。如果第一个比第二个大，就交换它们两个。 12345678910111213141516void BubbleSort(vector&lt;int&gt; &amp;nums){ int n = nums.size(); // 第i轮确定第i大的值，只需判断n-1轮 for (int i = 0; i &lt; n-1; ++i){ // 判断当前轮有无变化，没有变化说明已经排序完成 bool flag = false; // 后i+1位已经在之前轮排序完成 for (int j = 0; j &lt; n-1-i; ++j){ if (nums[j] &gt; nums[j+1]){ swap(nums[j], nums[j+1]); flag = true; } } if (!flag) break; }} 3 选择排序算法描述：分已排序区间和未排序区间。每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。 123456789101112void SelectSort(vector&lt;int&gt; &amp;nums){ int n = nums.size(); for (int i = 0; i &lt; n-1; ++i){ int pos = i; for (int j = i+1; j &lt; n; ++j){ if (nums[j] &lt; nums[pos]){ pos = j; } } swap(nums[pos], nums[i]); }} 4 插入排序算法描述：分为已排序和未排序，初始已排序区间只有一个元素 就是数组第一个，遍历未排序的每一个元素，在已排序区间里找到合适的位置插入并保证数据一直有序。 12345678910void InsertSort(vector&lt;int&gt; &amp;nums){ int n = nums.size(); for (int i = 1; i &lt; n; ++i){ for (int j = i; j &gt; 0; --j){ if (nums[j] &lt; nums[j-1]){ swap(nums[j], nums[j-1]); } } }} 5 希尔排序算法描述：通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终 位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步， 需排序的数据几乎是已排好的了。 1234567891011void ShellSort(vector&lt;int&gt; &amp;nums){ int n = nums.size(); for (int gap = n/2; gap &gt; 0; gap /= 2){ // 从index为gap的数开始插入，index在[0,gap-1]的数都是每组的第一个数 for (int i = gap; i &lt; n; ++i){ for (int j = i; j - gap &gt;= 0 &amp;&amp; nums[j-gap] &gt; nums[j]; j -= gap){ swap(nums[j], nums[j-gap]); } } }} 6 归并排序算法描述：归并排序是一种分治策略的排序算法。它是一种比较特殊的排序算法，通过递归地先使每个子序列有序，再将两个有序的序列进行合并成一个有序的序列。 123456789101112131415161718192021222324252627282930void MergeCount(vector&lt;int&gt; &amp;nums, int left, int mid, int right){ vector&lt;int&gt; tmp(right-left+1); int l = left, r = mid+1; int tmpIndex = 0; while(l &lt;= mid &amp;&amp; r &lt;= right){ if (nums[l] &lt; nums[r]){ tmp[tmpIndex++] = nums[l++]; }else{ tmp[tmpIndex++] = nums[r++]; } } while(l &lt;= mid){ tmp[tmpIndex++] = nums[l++]; } while(r &lt;= right){ tmp[tmpIndex++] = nums[r++]; } for (int i = left; i &lt;= right; ++i){ nums[i] = tmp[i-left]; }}void MergeSort(vector&lt;int&gt; &amp;nums, int left, int right){ if (left &gt;= right) return; int mid = left + (right-left)/2; MergeSort(nums, left, mid); MergeSort(nums, mid+1, right); MergeCount(nums, left, mid, right);} 7 快速排序算法描述：先找到一个标准，在原来的元素里根据这个标准划分比这个标准小的元素排前面，比这个标准大的元素 排后面，两部分数据依次递归排序下去直到最终有序。 12345678910111213void QuickSort(vector&lt;int&gt; &amp;nums, int left, int right){ if (left &gt;= right) return; int l = left + 1, r = right; while(l &lt; r){ while(l &lt; r &amp;&amp; nums[l] &lt;= nums[left]) { ++l; } if (l &lt; r) swap(nums[l], nums[r--]); while(l &lt; r &amp;&amp; nums[r] &gt;= nums[left]) { --r; } if (l &lt; r) swap(nums[l++], nums[r]); } swap(nums[left], nums[l]); QuickSort(nums, left, l-1); QuickSort(nums, l+1, right);} 8 堆排序算法描述：将待排序的序列构造成一个最大堆，此时序列的最大值为根节点。依次将根节点与待排序序列的最后一个元素交换。再维护从根节点到该元素的前一个节点为最大堆，如此往复，最终得到一个递增序列。 1234567891011121314151617181920212223242526272829void BuildHeap(vector&lt;int&gt; &amp;nums){ for (int i = 1; i &lt; nums.size(); ++i){ int temp = i; while(temp &gt; 0 &amp;&amp; nums[temp] &gt; nums[(temp-1)/2]){ swap(nums[temp], nums[(temp-1)/2]); temp = (temp-1)/2; } }}void Down(vector&lt;int&gt; &amp;nums, int i){ int maxPos = 0; while(1){ int index = maxPos; if (2*index+1 &lt;= i &amp;&amp; nums[2*index+1] &gt; nums[maxPos]){ maxPos = 2*index+1; } if (2*index+2 &lt;= i &amp;&amp; nums[2*index+2] &gt; nums[maxPos]){ maxPos = 2*index+2; } if (maxPos == index) break; swap(nums[maxPos], nums[index]); }}void HeapSort(vector&lt;int&gt; &amp;nums){ int n = nums.size(); BuildHeap(nums); for (int i = 1; i &lt; n; ++i){ swap(nums[0], nums[n-i]); Down(nums, n-i-1); }} 9 计数排序算法描述：需要知道待排序的数据的取值范围，使用辅助数组统计取值范围中取每个值的个数有几个，然后遍历取值范围输出。 123456789101112131415161718192021void CountSort(vector&lt;int&gt; &amp;nums){ int n = nums.size(), minNum = nums[0], maxNum = nums[0]; // 计算取值范围 for (int i = 1; i &lt; n; ++i){ minNum = min(minNum, nums[i]); maxNum = max(maxNum, nums[i]); } int k = maxNum-minNum+1; vector&lt;int&gt; count(k); // 统计每个值有几个 for (int i = 0; i &lt; n; ++i){ ++count[nums[i]-minNum]; } // 遍历统计数组输出 int sum = 0; for (int i = 0; i &lt; k; ++i){ for (int j = 0; j &lt; count[i]; ++j){ nums[sum++] = i+minNum; } }} 10 桶排序算法描述：将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。和计数排序的区别主要是桶有限，计数排序的桶数目和取值范围一样。 假设数据是均匀分布的，则每个桶的元素平均个数为 $\\frac{n}{k}$。假设选择用快速排序对每个桶内的元素进行排序，那么每次排序的时间复杂度为 $O(\\frac{n}{k}log\\frac{n}{k})$ 。总的时间复杂度为： $O(n) +O(k)\\times O(\\frac{n}{k}log\\frac{n}{k}) = O(n+O(nlog\\frac{n}{k}))=O(n+nlogn-nlogk)$。 当 k 接近于 n 时，桶排序的时间复杂度就可以近似认为是 O(n) 的。即桶越多，时间效率就越高，而桶越多，空间就越大。 11 基数排序算法描述：基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系， 如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 $O(n)$ 了。 12345678910111213141516171819202122232425262728293031323334void BaseSort(vector&lt;int&gt; &amp;nums){ // 得到最大位数 int n = nums.size(), maxNum = nums[0]; int d = 0; // 最大位数 for (auto i : nums){ if (i &gt; maxNum){ maxNum = i; } } while(maxNum){ maxNum /= 10; ++d; } int factor = 1; // 从个位排到第d位 for (int i = 1; i &lt;= d; ++i){ vector&lt;int&gt; bucket[10]; // 初始化10个桶 for (int j = 0; j &lt; n; ++j){ int temp = (nums[j]/factor) % 10; bucket[temp].push_back(nums[j]); } int index = 0; // 遍历10个桶，按从小到大顺序放入原数组 for (int j = 0; j &lt; 10; ++j){ int s = bucket[j].size(); for (int k = 0; k &lt; s; ++k){ nums[index++] = bucket[j][k]; } bucket[j].clear(); // 桶置空 } factor *= 10; }} Algorithm：十大经典排序算法C++实现及总结_51CTO博客_c++排序算法 (56条消息) 基数排序、桶排序和计数排序的区别_计数排序和桶排序_Rnan-prince的博客-CSDN博客 (56条消息) 堆排序算法（图解详细流程）_堆排序的详细过程_阿顾同学的博客-CSDN博客","link":"/2023/04/11/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++ Tools","slug":"C-Tools","link":"/tags/C-Tools/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"categories":[],"pages":[]}