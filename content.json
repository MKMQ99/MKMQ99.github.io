{"posts":[{"title":"GDB学习","text":"1 调试入门及基础篇1-1 Linux C/C++调试准备工作Ubuntu: apt install gcc g++ make gdb 123456789101112#include&lt;iostream&gt;int main(int argc,char**argv){ int itest=100; const char *str=&quot;this is a test&quot;; std::cout &lt;&lt; &quot;itest is &quot; &lt;&lt; itest &lt;&lt; &quot;,str is &quot; &lt;&lt; str &lt;&lt; std::endl; std::cout &lt;&lt; &quot;参数为:&quot; &lt;&lt; std::endl; for (int i = 0; i &lt; argc; i++){ std::cout &lt;&lt; argv[i] &lt;&lt; std::endl; } std::cout &lt;&lt; &quot;Hello world\\n&quot;; return 0;} 生成可调试的代码：g++ -g test.cpp -o test 进行调试：gdb test list：显示源码，一次默认显示10行 break/b：插入断点 info/i：查看信息 run/r：执行程序 next/n：执行一步 print/p：查看变量名 locals：看局部变量 continue/c：继续执行，直到下一个断点 1-2 启动调试1-2-1 启动调试并传入参数 gdb –args &lt;exe&gt; set args &lt;args&gt; r &lt;args&gt; gdb –args &lt;exe&gt; set args &lt;args&gt; r &lt;args&gt; 1-2-2 附加到进程，适用于已经启动的程序 gdb attach &lt;pid&gt; gdb –pid &lt;pid&gt; gdb attach &lt;pid&gt; gdb –pid &lt;pid&gt; 1-2-3 逐过程执行单步执行（step-over），遇到函数跳过函数 next/n 1-2-4 逐语句执行单步执行（step-into），遇到函数进入函数 step/s 1-2-5 退出当前函数finish 1-2-6 退出调试detach（分离） quit/q（退出） 1-3 调试断点管理1-3-1 设置断点 break/b 文件名:行号，在源代码某一行设置断点 b 函数名：为函数设置断点，同名函数会怎么样？（都添加断点） rb 正则表达式：为满足正则表达式的函数设置断点 b 断点条件：设置条件断点 tb 断点：设置临时断点（只命中一次） 1-3-2 查看/禁用/删除断点 i b：查看所有断点 disable/enable 断点编号：禁用，启用断点 delete 断点：删除断点 1-4 变量查看与修改1-4-1 变量查看 info args：查看函数参数 print/p 变量名：查看变量的值 set print null-stop：设置字符串的显示规则 set print pretty：显示结构体 set print array on：显示数组 使用gdb内嵌函数，比如sizeof,strlen,strcmp等 info args &amp;&amp; print/p 变量名 set print null-stop set print pretty set print array on 使用gdb内嵌函数 1-4-2 变量更改 p 变量=修改值：包括普通变量，结构体，类等 1-5 内存查看与修改1-5-1 内存查看 x /选项 内存地址 x /s str x /d x /4d x /16s 结构体变量地址 1-5-2 内存修改 set 地址=修改值 1-6 寄存器查看与修改1-6-1 查看寄存器 i registers i r rdi … 6个参数以内放寄存器，多的放栈 寄存器 函数参数 rdi 第一个参数 rsi 第二个参数 rdx 第三个参数 rcx 第四个参数 r8 第五个参数 r9 第六个参数 1-6-2 修改寄存器pc/rip (problem counter)寄存器，保存程序下一条要执行的指令，通过修改pc寄存器来改变程序执行的流程 set var $pc=xxx p $rip=xxx info line 行数：查看汇编代码地址 1-7 源代码管理、查看、搜索1-7-1 源代码管理 list/l：显示源代码，默认显示10行（l - ：向前显示） set listsize xx：设置每次显示的行数 list test_fun：查看指定函数代码 list main.cpp:15：查看指定文件指定行代码 1-7-2 搜索源代码 search 正则表达式 forward-search 正则表达式 reverse-search 正则表达式 1-7-3 设置源代码搜索目录show directories：查看当前搜索目录 directory path：添加源代码搜索目录 1-8 函数调用栈管理1-8-1 调用栈管理 backtrace/bt：查看栈回溯信息 frame/f n：切换栈帧 info f n(第几号栈帧)：查看栈帧信息 2 调试中级篇2-1 观察点使用观察点是一个特殊的断点，当表达式的值发生变化时它将中断下来。表达式可以是一个变量的值，也可以包含由运算符组合的一个或多个变量的值，例如a + b。有时被称为数据断点(VC里面就称之为数据断点) watch：写观察点，写变量的时候停下来，hardware watchpoint，不影响性能 rwatch：读观察点 awatch：读写观察点 info watch：查看观察点 delete/disable/enable：删除/禁用/启用观察点 表达式例子： 可指定线程：watch 变量名/表达式 thread 线程号 2-2 捕获点使用捕获点是一个特殊的断点，命令语法为：catch event即捕获到event这个事件的时候，程序就会中断下来 catch assert – Catch failed Ada assertions, when raised. catch catch – Catch an exception, when caught. catch exception – Catch Ada exceptions, when raised. catch exec – Catch calls to exec. catch fork – Catch calls to fork. catch handlers – Catch Ada exceptions, when handled. catch load – Catch loads of shared libraries. catch rethrow – Catch an exception, when rethrown. catch signal - Catch signals by their names and/or numbers. catch syscall – Catch system calls by their names, groups and/ornumbers. catch throw – Catch an exception, when thrown. catch unload – Catch unloads of shared libraries. catch vfork – Catch calls to vfork. 2-3 为断点执行命令1234commands 断点号xxxxxxend 不必每次在断点停下来的时候手动查看值 要删除的话直接commands不输入命令： 12commands 断点号end 导出断点信息：save breakpoints 文件名 加载断点信息：source 文件名 2-4 gdb多窗口管理Text User Interface（TUI） layout src：显示源码窗口 layout asm：显示汇编窗口 layout reg：显示寄存器窗口 layout split：切分窗口 focus/fs src/arm/reg：切换窗口焦点 info win：查看当前拥有焦点的窗口 ctrl+x+a：退出窗口模式 2-5 查看对象类型查看结构体，类，派生类等 whatis ptype /r /o /m /t i variables set print object on 2-6 多线程调试管理 info threads：查看所有线程信息 thread find 地址/LWP/线程名（正则表达式)：查找线程 thread num：切换线程 thread name：设置当前线程名字 b 断点地址 thread id：为线程设置断点 thread apply (多个)线程号 gdb命令：为线程执行命令（避免了切换线程） set print thread-events on|off：设置是否打印线程日志 2-7 执行外部命令以及保存命令及输出 shell/!：执行shell命令 pipe/| gdb命令 | grep 条件：对gdb输出进行筛选 set logging on/off：启用/禁用结果输出 set logging file filename：设置输出文件 set logging overwrite：覆盖输出文件，默认为追加 3 调试高级篇3-1 跳转执行-任意执行代码 jump/j location：即在指定位置恢复执行，如果存在断点，执行到指定位置时将中断下来。如果没有断点，则不会停下来，因此，我们通常会在指定位置设置一个断点。跳转命令不会更改当前堆栈帧、堆栈指针、程序计数器以外的任何寄存器。 3-2 反向执行-调试中的undo record：进行记录 reverse-next：反向运行到上一次被执行的源代码行，但是不进入函数 reverse-finish：反向运行程序回到调用当前函数的地方 record-stop：结束记录 不能用于IO操作 3-3 调试子进程 set follow-fork-mode child/parent：选择调试父进程还是子进程，默认父进程 set detach-on-fork off/on i inferiors：查看进程信息 inferiors n：切换进程 follow-fork-mode detach-on-fork 说明 parent on 只调试主进程( GDB 默认) child on 只调试子进程 parent off 同时调试两个进程, gdb 跟主进程, 子进程 block 在 fork 位置 child off 同时调试两个进程, gdb 跟子进程, 主进程 block 在 fork 位置 3-4 多进程调试先要将进程都attach进来 attach pid set schedule-multiple on detach inferior n 3-5 调试时调用内部、外部函数p表达式：求表达式的值并显示结果值。表达式可以包括对正在调试的程序中的函数的调用，即使函数返回值是void，也会显示。 call 表达式：求表达式的值并显示结果值，如果是函数调用，返回值是void的话，不显示void返回值。 3-6 调试时跳过指定函数指用step不会进入函数 skip 函数名 skip file 文件名：文件中的函数都会被跳过 skip -gfi 通配符：跳过满足通配符的文件 3-7 制作、调试发行版 去掉 -g 参数进行make（自己需要保留有调试信息的版本，所以要make两次） make Debug版本，然后使用 strip -g release-section -o release 命令去掉调试信息（只要make一次） gdb –symbol=release-section -exec=release objcopy –only-keep-debug release-section debug.sym：生成只有调试信息的文件，然后 gdb –symbol=debug.sym -exec=release gdb调试release版core dump文件：gdb release-section rel.core 3-8 软件补丁制作-直接编辑二进制程序 gdb –write 可执行文件：修改可执行文件 disassemble查看反汇编代码，例：disassemble /mr check_some p或者set修改机器码，例：set {unsigned char}0x00000000000011b4=101 4 调试实战篇4-1 内存泄漏检测 call malloc_stats() call malloc_info(0,stdout) 4-2 gcc检测各种内存问题检查：泄漏，栈溢出，野指针等gcc选项 -fsanitize=address检查内存泄漏检查堆溢出检查栈溢出检查全局内存溢出检查释放后再使用 4-3 远程调试1.服务器端/被调试机：安装 gdb server：apt install gdbserver 启动 gdbserver 2.客户端/调试机gdb远程连接并进行调试 4-4 多线程死锁调试分析死锁最常用的命令：thread、bt、f、p等 死锁的条件： 互斥条件 保持和请求条件 不可剥夺条件 循环等待条件 解决死锁的方式： 顺序使用锁 控制锁的作用范围 可以使用超时机制 4-5 核心转储（core dump）基础​ Linux core dump：一般称之为核心转储、内核转储，我们统称为转储文件是某个时刻某个进程的内存信息映射，即包含了生成转储文件时该进程的整个内存信息以及寄存器等信息。转储文件可以是某个进程的，也可以是整个系统的。可以是进程活着的时候生成的，也可以是进程或者系统崩溃的时候自动生成的。​ 为活着的进程创建core dump文件一般可以通过gdb来生成，使用gdb把进程attach进来以后，执行generate-core-file或者gcore命今来生成core dump文件。​ 我们更多时候是对崩溃产生的core dump文件进行分析。 ​ 崩溃时自动生成core文件，需要将 ulimit -c 设置为 unlimted，文件名由/proc/sys/kernel/core_pattern决定 ​ 查看问题：gdb 可执行文件 core文件 4-6 无调试符号core dump分析不能用p打印变量，但可以查看寄存器，查看内存地址的值 参考：SimpleSoft-2020/gdbdebug: gdb debug example (github.com)","link":"/2023/04/03/GDB%E5%AD%A6%E4%B9%A0/"},{"title":"MySQL事务基础与实现原理","text":"1 事务的基本概念事务一般指的是逻辑上的一组操作，或者作为单个逻辑单元执行的一系列操作。同属于一个事务的操作会作为一个整体提交给系统，这些操作要么全部执行成功，要么全部执行失败。 总体来说，事务存在四大特性（ACID），分别是原子性（Atomic）、一致性（Consistency）、隔离性 （Isolation）和持久性（Durability）。 原子性：构成事务的所有操作要么全部执行成功，要么全部执行失败，不可能出现部分执行成功，部分执行失败的情况。 一致性：在事务执行之前和执行之后，数据始终处于一致的状态。 隔离性：并发执行的两个事务之间互不干扰。MySQL 通过锁和 MVCC 机制来保证事务的隔离性。 持久性：是事务提交完成后，此事务对数据的更改操作会被持久化到数据库中，并且不会被回滚。 2 MySQL事务基础2.1 并发事务带来的问题 2.1.1 更新丢失（脏写）当两个或两个以上的事务选择数据库中的同一行数据，并基于最初选定的值更新该行数据时，因为每个事务之间都无法感知彼此的存在，所以会出现最后的更新操作覆盖之前由其他事务完成的更新操作的情况。也就是说，对于同一行数据，一个事务对该行数据的更新操作覆盖了其他事务对该行数据的更新操作。 例如，张三的账户余额是100元，当前有事务A和事务B两个事务，事务A是将张三的账户余额 增加100元，事务B是将张三的账户余额增加200元。起初，事务A和事务B同时读取到张三的账 户余额为100元。然后，事务A和事务B将分别更新张三的银行账户余额，假设事务A先于事务B提交，但事务A和事务B都提交后的结果是张三的账户余额是300元。也就是说，后提交的事务B覆盖了事务A的更新操作。 更新丢失（脏写）本质上是写操作的冲突，解决办法是让每个事务按照串行的方式执行，按照一定的顺序依次进行写操作。 2.1.2 脏读一个事务正在对数据库中的一条记录进行修改操作，在这个事务完成并提交之前，当有另一个事务来读取正在修改的这条数据记录时，如果没有对这两个事务进行控制，则第二个事务就会读取到没有被提交的脏数据，并根据这些脏数据做进一步的处理，此时就会产生未提交的数据依赖关系。我们通常把这种现象称为脏读，也就是一个事务读取了另一个事务未提交的数据。 例如，当前有事务A和事务B两个事务，事务A是向张三的银行账户转账100元，事务B是查询张三的账户余额。事务A执行转账操作，在事务A未提交时，事务B查询到张三的银行账户多了100元，后来事务A由于某些原因，例如服务超时、系统异常等因素进行回滚操作，但事务B查询到的数据并没有改变。此时，事务B查询到的数据就是脏数据。 脏读本质上是读写操作的冲突，解决办法是先写后读，也就是写完之后再读。 2.1.3 不可重复读一个事务读取了某些数据，在一段时间后，这个事务再次读取之前读过的数据，此时发现读取的数据发生了变化，或者其中的某些记录已经被删除，这种现象就叫作不可重复读。即同一个事务，使用相同的查询语句，在不同时刻读取到的结果不一致。 例如，当前有事务A和事务B两个事务，事务A是向张三的银行账户转账100元，事务B是查询张三的账户余额。第一次查询时，事务A还没有转账，第二次查询时，事务A已经转账成功，此 时，就会导致事务B两次查询结果不一致。 不可重复读本质上也是读写操作的冲突，解决办法是先读后写，也就是读完之后再写。 2.1.4 幻读一个事务按照相同的查询条件重新读取之前读过的数据，此时发现其他事务插入了满足当前事务查询条件的新数据，这种现象叫作幻读。即一个事务两次读取一个范围的数据记录，两次读取到的结果不同。 例如，当前有事务A和事务B两个事务，事务A是两次查询张三的转账记录，事务B是向张三的银行账户转账100元。事务A第一次查询时，事务B还没有转账，事务A第二次查询时，事务B已 经转账成功，此时，就会导致事务A两次查询的转账数据不一致。 幻读本质上是读写操作的冲突，解决办法是先读后写，也就是读完之后再写。 2.1.5 不可重复读与幻读的区别 不可重复读的重点在于更新和删除操作，而幻读的重点在于插入操作 幻读无法通过行级锁来避免，需要使用串行化的事务隔离级别，但是这种事务隔离级别会极大降低数据库的并发能力。 从本质上讲，不可重复读和幻读最大的区别在于如何通过锁机制解决问题。 另外，除了可以使用悲观锁来避免不可重复读和幻读的问题外，我们也可以使用乐观锁来处理，例如，MySQL、Oracle和PostgreSQL等数据库为了提高整体性能，就使用了基于乐观锁的MVCC（多版本并发控制）机制来避免不可重复读和幻读。 2.2 MySQL事务隔离级别MySQL中的InnoDB储存引擎提供 SQL标准所描述的4种事务隔离级别，分别为读未提交（Read Uncommitted）、读已提交 （Read Committed）、可重复读（Repeatable Read）和串行化（Serializable）。MySQL中的InnoDB默认为可重复读。Oracle默认为读已提交。 事务隔离级别 脏读 不可重复读 幻读 读未提交 可能 可能 可能 读已提交 不可能 可能 可能 可重复读 不可能 不可能 可能 串行化 不可能 不可能 不可能 2.3 MySQL中锁的分类 Some Tips 实现乐观锁的一种常用做法是为数据增加一个版本标识，如果是通过数据库实现，往往会在数据表中增加一个类似version的版本号字段。在查询数据表中的数据时，会将版本号字段的值一起读取出来，当更新数据时，会令版本号字段的值加1。将提交数据的版本与数据表对应记录的版本进行对比，如果提交的数据版本号大于数据表中当前要修改的数据的版本号，则对数据进行修改操作。否则，不修改数据表中的数据。 表锁开销比较小， 加锁速度快，一般不会出现死锁，锁定的粒度比较大，发生锁冲突的概率最高，并发度最低。行锁开销比较大，加锁速度慢，可能会出现死锁，锁定的粒度最小，发生锁冲突的概率最小，并发度最高。页面锁对数据的加锁开销介于表锁和行锁之间，可能会出现死锁，锁定的粒度大小介于表锁和行锁之间，并发度一般。 行锁主要加在索引上，如果对非索引的字段设置条件进行更新，行锁可能会变成表锁。 InnoDB的行锁是针对索引加锁，不是针对记录加锁，并且加锁的索引不能失效，否则行锁可能会变成表锁。 间隙锁只有在可重复读事务隔离级别下才会生效 2.4 MySQL中如何避免死锁 尽量让数据表中的数据检索都通过索引来完成，避免无效索引导致行锁升级为表锁。 合理设计索引，尽量缩小锁的范围。 尽量减少查询条件的范围，尽量避免间隙锁或缩小间隙锁的范围。 尽量控制事务的大小，减少一次事务锁定的资源数量，缩短锁定资源的时间。 如果一条SQL语句涉及事务加锁操作，则尽量将其放在整个事务的最后执行。 尽可能使用低级别的事务隔离机制。 3 MySQL事务实现原理从某种程度上说，事务的隔离性是由锁和 MVCC 机制实现的，原⼦性和持久性是由Redo Log实现的，一致性是由Undo Log实现的。 3.1 Redo LogRedo Log 确保MySQL事务提交后，事务所涉及的所有操作要么全部执行成功，要么全部执行失败。 3.1.1 Redo Log 基本原理Redo Log也被称作重做日志，它是在InnoDB存储引擎中产生的，用来保证事务的原⼦性和持 久性。Redo Log主要记录的是物理日志，也就是对磁盘上的数据进行的修改操作。Redo Log 往往用来恢复提交后的物理数据页，不过只能恢复到最后一次提交的位置。 Redo Log通常包含两部分：一部分是内存中的日志缓冲，称作Redo Log Buffer，这部分日志比较容易丢失；另一份是存放在磁盘上的重做日志文件，称作Redo Log File，这部分日志是持久化到磁盘上的，不容易丢失。 3.1.2 Redo Log 刷盘规则 在InnoDB存储引擎中，Redo Log具有以下几种刷盘规则。 开启事务，发出提交事务指令后是否刷新日志由变量innodb_flush_log_at_trx_commit决定 每秒刷新一次，刷新日志的频率由变量innodb_flush_log_at_timeout的值决定，默认是1s。 需要注意的是，刷新日志的频率和是否行了commit操作无关 当Log Buffer中已经使用的内存超过一半时，也会触发刷盘操作 对于第一条规则，在进行一定的说明。当事务提交时，需要先将事务日志写入Log Buffer，这些写入Log Buffer的日志并不是随着事务 的提交立刻写入磁盘的，而是根据一定的规则将Log Buffer中的数据刷写到磁盘，从而保证了 Redo Log文件中数据的持久性。这种刷盘规则可以通过innodb_flush_log_at_trx_commit变量 控制，innodb_flush_log_at_trx_commit变量可取的值有0、1和2，默认为1。 如果该变量设置为0，则每次提交事务时，不会将Log Buffer中的日志写入OS Buffer，而是通 过一个单独的线程，每秒写入OS Buffer并调用fsync()函数写入磁盘的Redo Log文件。这种方式不是实时写磁盘的，而是每隔1s写一次日志，如果系统崩溃，可能会丢失1s的数据 如果该变量设置为1，则每次提交事务都会将Log Buffer中的日志写入OS Buffer，并且会调用 fsync()函数将日志数据写入磁盘的Redo Log文件中。这种方式虽然在系统崩溃时不会丢失数 据，但是性能比较差。如果没有设置innodb_flush_log_at_trx_commit变量的值，则默认为1 如果该变量设置为2，则每次提交事务时，都只是将数据写入OS Buffer，之后每隔1s，通过 fsync()函数将OS Buffer中的日志数据同步写入磁盘的Redo Log文件中。 3.2 Undo LogUndo Log在MySQL事务的实现中主要起到两方面的作用：回滚事务和多版本并发事务，也就是常说的MVCC机制。在MySQL启动事务之前，会先将要修改的数据记录存储到Undo Log中。如果数据库的事务回滚或者MySQL数据库崩溃，可以利用Undo Log对数据库中未提交的事务进行回滚操作，从而保证数据库中数据的一致性。 Undo Log会在事务开始前产生，当事务提交时，并不会立刻删除相应的Undo Log。此时，InnoDB存储引擎会将当前事务对应的Undo Log放入待删除的列表，接下来，通过一个后台线程purge thread进行删除处理。 Undo Log与Redo Log不同，Undo Log记录的是逻辑日志，可以这样理解：当数据库执行一条 insert语句时，Undo Log会记录一条对应的delete语句；当数据库执行一条delete语句时，Undo Log会记录一条对应的insert语句；当数据库执行一条update语句时，Undo Log会记 录一条相反的update语句。 需要注意的是，因为MySQL事务执行过程中产生的Undo Log也需要进行持久化操作，所以 Undo Log也会产生Redo Log。由于Undo Log的完整性和可靠性需要Redo Log来保证，因此数据库崩溃时需要先做Redo Log数据恢复，然后做Undo Log回滚。 3.3 BinLogRedo Log是InnoDB存储引擎特有的日志，MySQL也有其自身的日志，这个日志就是BinLog， 即二进制日志。 3.3.1 BinLog基本概念BinLog是一种记录所有MySQL数据库表结构变更以及表数据变更的二进制日志。BinLog中不会记录诸如select和show这类查询操作的日志，同时，BinLog是以事件形式记录相关变更操作 的，并且包含语句执行所消耗的时间。BinLog有以下两个最重要的使用场景： 主从复制：在主数据库上开启BinLog，主数据库把BinLog发送至从数据库，从数据库获取BinLog后通过I/O线程将日志写到中继日志，也就是Relay Log中。然后，通过SQL线程将 Relay Log中的数据同步至从数据库，从而达到主从数据库数据的一致性。 数据恢复：当MySQL数据库发生故障或者崩溃时，可以通过BinLog进行数据恢复。例如， 可以使用mysqlbinlog等工具进行数据恢复。 3.3.2 BinLog记录模式BinLog文件中主要有3种记录模式，分别为Row、Statement和Mixed Row模式 Row模式下的BinLog文件会记录每一行数据被修改的情况，然后在MySQL从数据库中对相同的数据进行修改。 Row模式的优点是能够非常清楚地记录每一行数据的修改情况，完全实现主从数据库的同步和数据的恢复。 Row模式的缺点是如果主数据库中发生批量操作，尤其是大批量的操作，会产生大量的二进制日志。比如，使用alter table操作修改拥有大量数据的数据表结构时，会使二进制日志的内容暴涨，产生大量的二进制日志，从而大大影响主从数据库的同步性能。 Statement模式 Statement模式下的BinLog文件会记录每一条修改数据的SQL语句，MySQL从数据库在复制 SQL语句的时候，会通过SQL进程将BinLog中的SQL语句解析成和MySQL主数据库上执行过的 SQL语句相同的SQL语句，然后在从数据库上执行SQL进程解析出来的SQL语句。 Statement模式的优点是由于不记录数据的修改细节，只是记录数据表结构和数据变更的SQL 语句，因此产生的二进制日志数据量比较小，这样能够减少磁盘的I/O操作，提升数据存储和恢复的效率。 Statement模式的缺点是在某些情况下，可能会导致主从数据库中的数据不一致。例如，在 MySQL主数据库中使用了last_insert_id()和now()等函数，会导致MySQL主从数据库中的数据不一致。 Mixed模式 Mixed模式下的BinLog是Row模式和Statement模式的混用。在这种模式下，一般会使用 Statement模式保存BinLog，如果存在Statement模式⽆法复制的操作，例如在MySQL主数据库中使用了last_insert_id()和now()等函数，MySQL会使用Row模式保存BinLog。也就是说， 如果将BinLog的记录模式设置为Mixed,MySQL会根据执行的SQL语句选择写入的记录模式。 3.3.3 BinLog和Redo Log的区别 BinLog是MySQL本身就拥有的，不管使用何种存储引擎，BinLog都存在，而Redo Log是 InnoDB存储引擎特有的，只有InnoDB存储引擎才会输出Redo Log。 BinLog是一种逻辑日志，记录的是对数据库的所有修改操作，而Redo Log是一种物理日志，记录的是每个数据页的修改。 Redo Log具有幂等性，多次操作的前后状态是一致的，而BinLog不具有幂等性，记录的是所有影响数据库的操作。例如插入一条数据后再将其删除，则Redo Log前后的状态未发生变化，而BinLog就会记录插入操作和删除操作。 BinLog开启事务时，会将每次提交的事务一次性写入内存缓冲区，如果未开启事务，则每次成功执行插入、更新和删除语句时，就会将对应的事务信息写入内存缓冲区，而Redo Log是 在数据准备修改之前将数据写入缓冲区的Redo Log中，然后在缓冲区中修改数据。而且在提交事务时，先将Redo Log写入缓冲区，写入完成后再提交事务。 BinLog只会在事务提交时，一次性写入BinLog，其日志的记录方式与事务的提交顺序有 关，并且一个事务的BinLog中间不会插入其他事务的BinLog。而Redo Log记录的是物理页的修改，最后一个提交的事务记录会覆盖之前所有未提交的事务记录，并且一个事务的Redo Log 中间会插入其他事务的Redo Log。 BinLog是追加写入，写完一个日志文件再写下一个日志文件，不会覆盖使用，而Redo Log 是循环写入，日志空间的大小是固定的，会覆盖使用。 BinLog一般用于主从复制和数据恢复，并且不具备崩溃自动恢复的能力，而Redo Log是在服务器发生故障后重启MySQL，用于恢复事务已提交但未写入数据表的数据。 参考：深入理解分布式事务：原理与实战","link":"/2023/04/05/MySQL%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/04/03/hello-world/"},{"title":"使用chatgpt练习gdb","text":"奇怪的想法chatgpt有着出色的代码生成能力，于是想利用chatgpt生成含bug代码，训练一下gdb水平。 Test 1 先运行代码，输出的结果是 其实肉眼已经看出来是数组越界访问了，没关系，我们当作不知道，用gdb来debug 先在find_max_index打一个断点，看一看传进去的变量，可以看到arr数组正确，长度为5正确 然后在循环出打个条件断点，在 i == 5 的时候停下，为什么是5？因为开天眼了。在实践中发现在for语句打变量条件断点会失败？？？只能打在for循环中的第一句。然后我们查看一下变量值，发现问题 关于for语句打变量条件断点会失败：尝试后发现，在for语句打断点，只会在第一次进入for时停止，之后便不再触发。 Test 2 拿到代码先运行，愉快死锁 查看进程的pid，pid为8970，attach进行调试 之后我们先看一看线程信息 可以看到有三个线程，一个主线程，两个子线程，Thread2 正在等待 mutex2，Thread3 正在等待 mutex1，然后打印 mutex1和mutex2 可以看到 mutex1 的拥有者是线程8971，就是Thread2，mutex2 的拥有者是线程8972，就是 Thread3，所以死锁。","link":"/2023/04/12/%E4%BD%BF%E7%94%A8chatgpt%E7%BB%83%E4%B9%A0gdb/"},{"title":"常用设计模式","text":"1 设计模式的六大原则 SRP（Single Responsibility Principle）：单一职责原则，一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。 OCP（Open Close Principle）：开放封闭原则，软件实体可以扩展，但是不可修改。即面对需求，对程序的改动可以通过增加代码来完成，但是不能改动现有的代码。 LSP（Liskov Substitution Principle）：里氏代换原则，就是基类出现的地方，通过它的子类也完全可以实现这个功能。 DIP（Dependence Inversion Principle）：依赖倒置原则，高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象，其核心思想是：要面向接口编程，不要面向实现编程。 ISP（Interface Segregation Principle）：接口隔离原则，建立一接口，尽量细化接口，接口中的方法尽量少。每个接口中不存在派生类用不到却必须实现的方法，如果不然，就要将接口拆分，使用多个隔离的接口。 CRP（Composite Reuse Principle）：迪米特原则，如果两个类不直接通信，那么这两个类就不应当发生直接的相互作用。如果一个类需要调用另一个类 的某个方法的话，可以通过第三个类转发这个调用。 2 三类设计模式 创造型模式：单例模式、工厂模式、建造者模式、原型模式 结构型模式：适配器模式、桥接模式、外观模式、组合模式、装饰模式、享元模式、代理模式 行为型模式：责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式、访问者模式 3 常见设计模式3.1 单例模式保证一个类仅有一个实例，并提供一个访问它的全局访问点。 有两种，懒汉和饿汉： 饿汉：饿了就饥不择食了，所以在单例类定义的时候就进行实例化。 懒汉：顾名思义，不到万不得已就不会去实例化类，也就是在第一次用到的类实例的时候才会去实例化。 饿汉模式（线程安全） 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;class SingleInstance{ public: static SingleInstance* GetInstance(){ static SingleInstance ins; return &amp;ins; } ~SingleInstance(){}; private: // 涉及到创建对象的函数都设置为private SingleInstance() { std::cout&lt;&lt;&quot;SingleInstance() 饿汉&quot;&lt;&lt;std::endl; } SingleInstance(const SingleInstance&amp; other) {}; SingleInstance&amp; operator=(const SingleInstance&amp; other) {return *this;}};int main(){ //因为不能创建对象所以通过静态成员函数的⽅法返回静态成员变量 SingleInstance* ins = SingleInstance::GetInstance(); return 0;}//输出 SingleInstance() 饿汉 懒汉模式（线程安全需要加锁） 尽可能的晚的创建这个对象的实例，即在单例类第一次被引用的时候就将自己初始化，C++ 很多地方都有类型的思想，比如写时拷贝，晚绑定等。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;thread&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;class SingleInstance{ public: static SingleInstance* GetInstance(){ if (ins == nullptr){ lock_guard&lt;mutex&gt; lck(mLock); if (ins == nullptr){ ins = new SingleInstance(); } } return ins; } ~SingleInstance(){}; private: //涉及到创建对象的函数都设置为private SingleInstance() { std::cout&lt;&lt;&quot;SingleInstance() 懒汉&quot;&lt;&lt;std::endl; } SingleInstance(const SingleInstance&amp; other) {}; SingleInstance&amp; operator=(const SingleInstance&amp; other) { return *this; } static mutex mLock; static SingleInstance* ins;};//懒汉式 静态变量需要定义SingleInstance* SingleInstance::ins = nullptr;mutex SingleInstance::mLock;int main(){ //因为不能创建对象所以通过静态成员函数的⽅法返回静态成员变ᰁ SingleInstance* ins = SingleInstance::GetInstance(); delete ins; return 0;}//输出 SingleInstance() 懒汉 3.2 工厂模式简单工厂模式： 就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std;// 产品类（抽象类，不能实例化）class Product{ public: Product(){}; virtual void show()=0; //纯虚函数};class productA : public Product{ public: productA(){}; void show(){ std::cout &lt;&lt; &quot;product A create!&quot; &lt;&lt; std::endl; }; ~productA(){};};class productB : public Product{ public: productB(){}; void show(){ std::cout &lt;&lt; &quot;product B create!&quot; &lt;&lt; std::endl; }; ~productB(){};};// 工厂类class simpleFactory{ public: simpleFactory(){}; Product* product(const string str){ if (str == &quot;productA&quot;) return new productA(); if (str == &quot;productB&quot;) return new productB(); return NULL; };};int main(){ simpleFactory obj; // 创建工厂 Product* pro; // 创建产品 pro = obj.product(&quot;productA&quot;); pro-&gt;show(); // product A create! delete pro; pro = obj.product(&quot;productB&quot;); pro-&gt;show(); // product B create! delete pro; return 0;} 工厂模式目的就是代码解耦，如果我们不采用工厂模式，如果要创建产品 A、B，通常做法采用switch…case语 句，那么想后期添加更多的产品进来，我们不是要添加更多的 switch…case 吗？这样就很麻烦，而且也不符合设计模式中的开放封闭原则。 为了进一步解耦，在简单工厂的基础上发展出了抽象工厂模式，即连工厂都抽象出来，实现了进一步代码解耦。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;thread&gt;using namespace std;// 产品类（抽象类，不能实例化）class Product{ public: Product(){}; virtual void show()=0; //纯虚函数};//抽象类class Factory{ public: virtual Product* CreateProduct()=0;//纯虚函数};class productA : public Product{ public: productA(){}; void show(){ std::cout &lt;&lt; &quot;product A create!&quot; &lt;&lt; std::endl; }; ~productA(){};};class productB : public Product{ public: productB(){}; void show(){ std::cout &lt;&lt; &quot;product B create!&quot; &lt;&lt; std::endl; }; ~productB(){};};//⼯⼚类A，只⽣产A产品class FactorA: public Factory{ public: Product* CreateProduct(){ Product* product_ = new ProductA(); return product_; }};//⼯⼚类B，只⽣产B产品class FactorB: public Factory{ public: Product* CreateProduct(){ Product* product_ = new ProductB(); return product_; }};int main(){ Product* product_ = nullptr; auto MyFactoryA = new FactorA(); product_ = MyFactoryA-&gt;CreateProduct();// 调用产品A的⼯⼚来⽣产A产品 product_-&gt;show(); delete product_; auto MyFactoryB=new FactorB(); product_ = MyFactoryB-&gt;CreateProduct();// 调用产品B的⼯⼚来⽣产B产品 product_-&gt;show(); delete product_; return 0;}//输出//product A create! product B create! 3.3 观察者模式定义一种一（被观察类）对多（观察类）的关系，让多个观察对象同时监听一个被观察对象，被观察对象状态发生变化时，会通知所有的观察对象，使他们能够更新自己的状态。 观察者模式中存在两种角色： 观察者：内部包含被观察者对象，当被观察者对象的状态发生变化时，更新自己的状态（接收通知更新状态） 被观察者：内部包含了所有观察者对象，当状态发生变化时通知所有的观察者更新自己的状态（发送通知） 应用场景：当一个对象的改变需要同时改变其他对象，且不知道具体有多少对象有待改变时，应该考虑使用观察者模式；一个抽象模型有两个方面，其中一方面依赖于另一方面，这时可以用观察者模式将这两者封装在独立的对象中使它们各自独立地改变和复用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;list&gt;using namespace std;class Subject;//观察者 基类 （内部实例化了被观察者的对象sub）class Observer { protected: string name; Subject *sub; public: Observer(string name, Subject *sub) { this-&gt;name = name; this-&gt;sub = sub; } virtual void update() = 0;};class StockObserver : public Observer { public: StockObserver(string name, Subject *sub) : Observer(name, sub){} void update();};class NBAObserver : public Observer { public: NBAObserver(string name, Subject *sub) : Observer(name, sub){} void update();};//被观察者基类 （内部存放了所有的观察者对象，以便状态发⽣变化时，给观察者发通知）class Subject { protected: std::list&lt;Observer *&gt; observers; public: string action; //被观察者对象的状态 virtual void attach(Observer *) = 0; virtual void detach(Observer *) = 0; virtual void notify() = 0;};class Secretary : public Subject { void attach(Observer *observer) { observers.push_back(observer); } void detach(Observer *observer) { list&lt;Observer *&gt;::iterator iter = observers.begin(); while (iter != observers.end()) { if ((*iter) == observer) { observers.erase(iter); return; } ++iter; } } void notify() { list&lt;Observer *&gt;::iterator iter = observers.begin(); while (iter != observers.end()) { (*iter)-&gt;update(); ++iter; } }};void StockObserver::update() { cout &lt;&lt; name &lt;&lt; &quot; 收到消息：&quot; &lt;&lt; sub-&gt;action &lt;&lt; endl; if (sub-&gt;action == &quot;⽼板来了!&quot;) { cout &lt;&lt; &quot;我⻢上关闭股票，装做很认真⼯作的样⼦！&quot; &lt;&lt; endl; }}void NBAObserver::update() { cout &lt;&lt; name &lt;&lt; &quot; 收到消息：&quot; &lt;&lt; sub-&gt;action &lt;&lt; endl; if (sub-&gt;action == &quot;⽼板来了!&quot;) { cout &lt;&lt; &quot;我⻢上关闭 NBA，装做很认真⼯作的样⼦！&quot; &lt;&lt; endl; }}int main(){ Subject *BOSS = new Secretary(); Observer *xa = new NBAObserver(&quot;xa&quot;, BOSS); Observer *xb = new NBAObserver(&quot;xb&quot;, BOSS); Observer *xc = new StockObserver(&quot;xc&quot;, BOSS); BOSS-&gt;attach(xa); BOSS-&gt;attach(xb); BOSS-&gt;attach(xc); BOSS-&gt;action = &quot;去吃饭了！&quot;; BOSS-&gt;notify(); cout &lt;&lt; endl; BOSS-&gt;action = &quot;⽼板来了!&quot;; BOSS-&gt;notify(); return 0;} 3.4 装饰器模式装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。 这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。 代码没有改变 Car 类的内部结构，还为其增加了新的功能，这就是装饰器模式的作用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;memory&gt;using namespace std;//抽象构件类 Transform (变形⾦刚)class Transform{ public: virtual void move() = 0;};//具体构件类Carclass Car : public Transform{ public: Car(){ std::cout &lt;&lt; &quot;变形⾦刚是⼀辆⻋！&quot; &lt;&lt; endl; } void move(){ std::cout &lt;&lt; &quot;在陆地上移动。&quot; &lt;&lt; endl; }};//抽象装饰类class Changer : public Transform{ public: Changer(shared_ptr&lt;Transform&gt; transform){ this-&gt;transform = transform; } void move(){ transform-&gt;move(); } private: shared_ptr&lt;Transform&gt; transform;};//具体装饰类Robotclass Robot : public Changer{ public: Robot(shared_ptr&lt;Transform&gt; transform) : Changer(transform){ std::cout &lt;&lt; &quot;变成机器⼈!&quot; &lt;&lt; std::endl; } void say(){ std::cout &lt;&lt; &quot;说话!&quot; &lt;&lt; std::endl; }};//具体装饰类AirPlaneclass Airplane : public Changer{ public: Airplane(shared_ptr&lt;Transform&gt; transform) : Changer(transform){ std::cout &lt;&lt; &quot;变成⻜机!&quot; &lt;&lt; std::endl; } void say(){ std::cout &lt;&lt; &quot;在天空⻜翔!&quot; &lt;&lt; std::endl; } };int main(void){ shared_ptr&lt;Transform&gt; camaro = make_shared&lt;Car&gt;(); camaro-&gt;move(); std::cout &lt;&lt; &quot;--------------&quot; &lt;&lt; endl; shared_ptr&lt;Robot&gt; bumblebee = make_shared&lt;Robot&gt;(camaro); bumblebee-&gt;move(); bumblebee-&gt;say(); return 0;}/*输出变形⾦刚是⼀辆⻋！在陆地上移动。--------------变成机器⼈!在陆地上移动。说话!*/ 参考： 常见C++设计模式面试题和场景题_牛客网 (nowcoder.com) 20 万字的 C++ 八股文&amp;图解源码，发布！ (qq.com)","link":"/2023/04/10/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"title":"常见排序算法","text":"1 常见排序算法及其时间和空间复杂度 排序算法 平均时间复杂度 最好情况 最坏情况 空间复杂度 稳定性 冒泡排序 $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ 稳定 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ 不稳定 插入排序 $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ 稳定 希尔排序 $O(n^\\frac{3}{2})$ $O(nlog2n)$ $O(n^2)$ $O(1)$ 不稳定 归并排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ $O(n)$ 稳定 快速排序 $O(nlogn)$ $O(nlogn)$ $O(n^2)$ $O(logn)$ 不稳定 堆排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ $O(1)$ 不稳定 计数排序 $O(n+k)$ $O(n+k)$ $O(n+k)$ $O(k)$ 稳定 桶排序 $O(n+k)$ $O(n+k)$ $O(n^2)$ $O(n+k)$ 稳定 基数排序 $O(n\\times k)$ $O(n\\times k)$ $O(n\\times k)$ $O(n+k)$ 稳定 2 冒泡排序算法描述：比较相邻的元素。如果第一个比第二个大，就交换它们两个。 12345678910111213141516void BubbleSort(vector&lt;int&gt; &amp;nums){ int n = nums.size(); // 第i轮确定第i大的值，只需判断n-1轮 for (int i = 0; i &lt; n-1; ++i){ // 判断当前轮有无变化，没有变化说明已经排序完成 bool flag = false; // 后i+1位已经在之前轮排序完成 for (int j = 0; j &lt; n-1-i; ++j){ if (nums[j] &gt; nums[j+1]){ swap(nums[j], nums[j+1]); flag = true; } } if (!flag) break; }} 3 选择排序算法描述：分已排序区间和未排序区间。每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。 123456789101112void SelectSort(vector&lt;int&gt; &amp;nums){ int n = nums.size(); for (int i = 0; i &lt; n-1; ++i){ int pos = i; for (int j = i+1; j &lt; n; ++j){ if (nums[j] &lt; nums[pos]){ pos = j; } } swap(nums[pos], nums[i]); }} 4 插入排序算法描述：分为已排序和未排序，初始已排序区间只有一个元素 就是数组第一个，遍历未排序的每一个元素，在已排序区间里找到合适的位置插入并保证数据一直有序。 12345678910void InsertSort(vector&lt;int&gt; &amp;nums){ int n = nums.size(); for (int i = 1; i &lt; n; ++i){ for (int j = i; j &gt; 0; --j){ if (nums[j] &lt; nums[j-1]){ swap(nums[j], nums[j-1]); } } }} 5 希尔排序算法描述：通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终 位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步， 需排序的数据几乎是已排好的了。 1234567891011void ShellSort(vector&lt;int&gt; &amp;nums){ int n = nums.size(); for (int gap = n/2; gap &gt; 0; gap /= 2){ // 从index为gap的数开始插入，index在[0,gap-1]的数都是每组的第一个数 for (int i = gap; i &lt; n; ++i){ for (int j = i; j - gap &gt;= 0 &amp;&amp; nums[j-gap] &gt; nums[j]; j -= gap){ swap(nums[j], nums[j-gap]); } } }} 6 归并排序算法描述：归并排序是一种分治策略的排序算法。它是一种比较特殊的排序算法，通过递归地先使每个子序列有序，再将两个有序的序列进行合并成一个有序的序列。 123456789101112131415161718192021222324252627282930void MergeCount(vector&lt;int&gt; &amp;nums, int left, int mid, int right){ vector&lt;int&gt; tmp(right-left+1); int l = left, r = mid+1; int tmpIndex = 0; while(l &lt;= mid &amp;&amp; r &lt;= right){ if (nums[l] &lt; nums[r]){ tmp[tmpIndex++] = nums[l++]; }else{ tmp[tmpIndex++] = nums[r++]; } } while(l &lt;= mid){ tmp[tmpIndex++] = nums[l++]; } while(r &lt;= right){ tmp[tmpIndex++] = nums[r++]; } for (int i = left; i &lt;= right; ++i){ nums[i] = tmp[i-left]; }}void MergeSort(vector&lt;int&gt; &amp;nums, int left, int right){ if (left &gt;= right) return; int mid = left + (right-left)/2; MergeSort(nums, left, mid); MergeSort(nums, mid+1, right); MergeCount(nums, left, mid, right);} 7 快速排序算法描述：先找到一个标准，在原来的元素里根据这个标准划分比这个标准小的元素排前面，比这个标准大的元素 排后面，两部分数据依次递归排序下去直到最终有序。 12345678910111213void QuickSort(vector&lt;int&gt; &amp;nums, int left, int right){ if (left &gt;= right) return; int l = left + 1, r = right; while(l &lt; r){ while(l &lt; r &amp;&amp; nums[l] &lt;= nums[left]) { ++l; } if (l &lt; r) swap(nums[l], nums[r--]); while(l &lt; r &amp;&amp; nums[r] &gt;= nums[left]) { --r; } if (l &lt; r) swap(nums[l++], nums[r]); } swap(nums[left], nums[l]); QuickSort(nums, left, l-1); QuickSort(nums, l+1, right);} 8 堆排序算法描述：将待排序的序列构造成一个最大堆，此时序列的最大值为根节点。依次将根节点与待排序序列的最后一个元素交换。再维护从根节点到该元素的前一个节点为最大堆，如此往复，最终得到一个递增序列。 1234567891011121314151617181920212223242526272829void BuildHeap(vector&lt;int&gt; &amp;nums){ for (int i = 1; i &lt; nums.size(); ++i){ int temp = i; while(temp &gt; 0 &amp;&amp; nums[temp] &gt; nums[(temp-1)/2]){ swap(nums[temp], nums[(temp-1)/2]); temp = (temp-1)/2; } }}void Down(vector&lt;int&gt; &amp;nums, int i){ int maxPos = 0; while(1){ int index = maxPos; if (2*index+1 &lt;= i &amp;&amp; nums[2*index+1] &gt; nums[maxPos]){ maxPos = 2*index+1; } if (2*index+2 &lt;= i &amp;&amp; nums[2*index+2] &gt; nums[maxPos]){ maxPos = 2*index+2; } if (maxPos == index) break; swap(nums[maxPos], nums[index]); }}void HeapSort(vector&lt;int&gt; &amp;nums){ int n = nums.size(); BuildHeap(nums); for (int i = 1; i &lt; n; ++i){ swap(nums[0], nums[n-i]); Down(nums, n-i-1); }} 9 计数排序算法描述：需要知道待排序的数据的取值范围，使用辅助数组统计取值范围中取每个值的个数有几个，然后遍历取值范围输出。 123456789101112131415161718192021void CountSort(vector&lt;int&gt; &amp;nums){ int n = nums.size(), minNum = nums[0], maxNum = nums[0]; // 计算取值范围 for (int i = 1; i &lt; n; ++i){ minNum = min(minNum, nums[i]); maxNum = max(maxNum, nums[i]); } int k = maxNum-minNum+1; vector&lt;int&gt; count(k); // 统计每个值有几个 for (int i = 0; i &lt; n; ++i){ ++count[nums[i]-minNum]; } // 遍历统计数组输出 int sum = 0; for (int i = 0; i &lt; k; ++i){ for (int j = 0; j &lt; count[i]; ++j){ nums[sum++] = i+minNum; } }} 10 桶排序算法描述：将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。和计数排序的区别主要是桶有限，计数排序的桶数目和取值范围一样。 假设数据是均匀分布的，则每个桶的元素平均个数为 $\\frac{n}{k}$。假设选择用快速排序对每个桶内的元素进行排序，那么每次排序的时间复杂度为 $O(\\frac{n}{k}log\\frac{n}{k})$ 。总的时间复杂度为： $O(n) +O(k)\\times O(\\frac{n}{k}log\\frac{n}{k}) = O(n+O(nlog\\frac{n}{k}))=O(n+nlogn-nlogk)$。 当 k 接近于 n 时，桶排序的时间复杂度就可以近似认为是 O(n) 的。即桶越多，时间效率就越高，而桶越多，空间就越大。 11 基数排序算法描述：基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系， 如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 $O(n)$ 了。 12345678910111213141516171819202122232425262728293031323334void BaseSort(vector&lt;int&gt; &amp;nums){ // 得到最大位数 int n = nums.size(), maxNum = nums[0]; int d = 0; // 最大位数 for (auto i : nums){ if (i &gt; maxNum){ maxNum = i; } } while(maxNum){ maxNum /= 10; ++d; } int factor = 1; // 从个位排到第d位 for (int i = 1; i &lt;= d; ++i){ vector&lt;int&gt; bucket[10]; // 初始化10个桶 for (int j = 0; j &lt; n; ++j){ int temp = (nums[j]/factor) % 10; bucket[temp].push_back(nums[j]); } int index = 0; // 遍历10个桶，按从小到大顺序放入原数组 for (int j = 0; j &lt; 10; ++j){ int s = bucket[j].size(); for (int k = 0; k &lt; s; ++k){ nums[index++] = bucket[j][k]; } bucket[j].clear(); // 桶置空 } factor *= 10; }} 参考： Algorithm：十大经典排序算法C++实现及总结_51CTO博客_c++排序算法 (56条消息) 基数排序、桶排序和计数排序的区别_计数排序和桶排序_Rnan-prince的博客-CSDN博客 (56条消息) 堆排序算法（图解详细流程）_堆排序的详细过程_阿顾同学的博客-CSDN博客","link":"/2023/04/11/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"title":"剖析HTTPS","text":"本来只是想仔细研究一下https，不过既然要做了，那就把整个网站访问的包都分析一下吧。本文将详解在edge浏览器输入 https://oc.sjtu.edu.cn 会发生什么。 1 DNS显然，第一步得知道域名对应的IP地址，所以会发送DNS报文。 可以看到这里DNS报文都是两条两条发送回应的，原因应该是本人所处网络为IPV6环境，所以发送DNS报文时会发送一个IPV4版本的和一个IPV6版本的。 A（Address）记录指定域名对应的IP地址，更多类型可看DNS记录类型介绍(A记录、MX记录、NS记录等)-阿里云开发者社区 (aliyun.com)了解。 2 TCP既然知道了ip为202.120.35.235，这下可以对ip包进行筛选了，在wireshark使用ip.addr == 202.120.35.235即可 可以看到有两个TCP连接，这个蛮迷惑的，搜索后有一个解释为： 可以看到火狐浏览器中正常：一次请求只建立一次tcp连接。我们尝试了curl发起请求，抓包记录都是一次tcp连接。基本确定不是浏览器的共性，只是谷歌浏览器的个性。使用多个连接通常最容易想到的是加速访问，比如一个数据库连接不够用，可以建立多个连接（连接池复用连接）。 但是数据包还是好多，可以使用tcp.stream eq 3追踪一条tcp流 显然，数据包还是很多…… 前面是三次握手，没啥好说的。有一个点是来回的MSS不一样，这是在通告对方自己的MSS，然后取小的来。 3 TLSv1.2这是我真正想要关注的东西，再加一条tls过滤条件，数据包可以看到有四个tls协议包。 3.1 第一次握手Client Hello 首先可以看到这个是TLS握手协议 理论上来说，TLS主要分为两层，底层的是TLS记录协议，主要负责使用对称密码对消息进行加密；上层的是TLS握手协议，主要分为握手协议，密码规格变更协议、警告协议和应用数据协议4个部分。 握手协议负责在客户端和服务器端商定密码算法和共享密钥，包括证书认证，是4个协议中最最复杂的部分。 密码规格变更协议负责向通信对象传达变更密码方式的信号 警告协议负责在发生错误的时候将错误传达给对方 应用数据协议负责将TLS承载的应用数据传达给通信对象的协议。 [Client Hello] 给出了很多信息，包括 可用版本号 当前时间 客户端随机数 会话ID 可用的密码套件清单 可用的压缩方式清单 3.2 第二次握手Server Hello &amp; Certificate &amp; Server Hello Done 前面说过，握手协议包含四个部分，这里三个合并的消息都属于握手协议。 3.2.1 Server Hello回应了 [Client Hello] 消息，回复内容包括 使用的版本号 当前时间 服务端随机数 会话ID 使用的密码套件清单 使用的压缩方式清单 上图中服务端选择的算法套件是：TLS__RSA_WITH_AES_256_CBC_SHA (0x0035), 它的意思是： 密钥交换算法采用：RSA 签名算法采用：RSA 加密算法采用：AES对称算法，密钥长度为256bit, 模式为：CBC。 摘要算法采用：SHA 3.2.2 Certificate发送服务端证书，这里发了两张证书 3.2.3 Server Hello Done服务端发送 [Server Hello Done] 消息，告诉客户端，我已经把该给你的东西都给你了，本次打招呼完毕。 3.3 第三次握手Client Key Exchange &amp; Change Cipher Spec &amp; Encrypted Handshake Message 这三个消息分别属于握手协议、密码规格变更协议、握手协议。 3.3.1 Client Key Exchange客户端验证完证书后，认为可信则继续往下走。接着，客户端就会生成一个新的随机数 (pre-master)，用服务器的 RSA 公钥加密该随机数，通过 [Client Key Exchange] 消息传给服务端。 服务端收到后，用 RSA 私钥解密，得到客户端发来的随机数 (pre-master)。 至此，客户端和服务端双方都共享了三个随机数，分别是 Client Random、Server Random、pre-master。于是，双方根据已经得到的三个随机数，生成会话密钥（Master Secret），它是对称密钥，用于对后续的请求/响应的数据加解密。 3.3.2 Change Cipher Spec上一步生成了会话密钥，所以客户端发一个 **[Change Cipher Spec]**，告诉服务端开始使用加密方式发送消息。 3.3.3 Encrypted Handshake Message[Encrypted Handshake Message] 消息，把之前所有发送的数据做个摘要，再用会话密钥（master secret）加密一下，让服务器做个验证，验证加密通信是否可用和之前握手信息是否有被中途篡改过。 3.4 第四次握手Change Cipher Spec &amp; Encrypted Handshake Message 3.4.1 Change Cipher Spec服务端告诉客户端开始使用加密方式发送消息 3.4.2 Encrypted Handshake Message和3.3.3功能一样 4 番外4.1 DNS CNAME记录这里扯一下DNS CNAME记录，是在访问 www.baidu.com 时遇到的。 一个DNS CNAME记录将一个主机名映射到另一个。这意味着你可以有多个具有相同IP地址的主机，但每个主机都有一个不同的名字。CANME的好处是：在下图例子中，如果我调整了 Web 服务器，将它迁移到另一台主机上，我只需修改 webserver.fasionchan.com 一个域名，其他专栏域名均无须调整。 4.2 RSA算法的缺陷使用 RSA 密钥协商算法的最大问题是不支持前向保密。 因为客户端传递随机数（用于生成对称加密密钥的条件之一）给服务端时使用的是公钥加密的，服务端收到后，会用私钥解密得到随机数。所以一旦服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解。 为了解决这个问题，后面就出现了 ECDHE 密钥协商算法。 4.3 JA3和JA3S在 [Client Hello] 中包含一个字段叫 JA3 ，在**[Server Hello]** 中包含字段 JA3S，这两者是什么？ JA3(S) 是为特定客户端与服务器之间的加密通信提供了具有更高的识别度的指纹，说白了就是 TLS 协商的指纹。它的用处是识别恶意客户端和服务器之间的 TLS 协商。 例如，现在的 C2 服务器（Command and Control server，命令和控制服务器）与恶意客户端之间的通信往往都是套上 TLS 的，将其流量隐藏在噪声中来躲避 IDS/IPS（入侵检测/入侵预防），这样光从 ip/域名这个维度去检测难免会漏掉一些。如果我们掌握了 C2 服务器与恶意客户端的 JA3(S)，即使恶意流量被加密且不知道 C2 服务器的 IP 地址或域名，我们仍然可以通过 TLS 指纹来识别恶意客户端和服务器之间的 TLS 协商。 那么难道JA3(S)不能改变吗？当然是可以的，但是会提高成本：改个 ip 或者域名，比修改客户端程序方便多了。 JA3S 不能单独使用，必须与 JA3 结合使用才能更有效地进行检测或列入黑名单。当成对使用时，它还可以减少误报的数量。此外，如果我们只使用 JA3 指纹，我们很可能会看到稳定的流量，其中大部分是合规范的。JA3+JA3S 依旧不会非常准确，但是可以丰富我们检测威胁的维度，增加了攻击者的攻击成本。 参考： DNS记录类型介绍(A记录、MX记录、NS记录等)-阿里云开发者社区 (aliyun.com) 什么是DNS CNAME记录？CNAME记录的简易指南 (powerdmarc.com) DNS记录类型 | 小菜学网络 (fasionchan.com) (56条消息) 谷歌浏览器，一次get请求建立两次tcp连接_wireshark谷歌_码农小麦的博客-CSDN博客 (99+ 封私信 / 80 条消息) 为什么TCP的MSS协商没有按照小的来？ - 知乎 (zhihu.com) 3.3 HTTPS RSA 握手解析 | 小林coding (xiaolincoding.com) JA3(S)，简单而有效的 TLS 指纹 - Tr0y’s Blog C2 - katago - 博客园 (cnblogs.com)","link":"/2023/04/14/%E5%89%96%E6%9E%90HTTPS/"},{"title":"线程间共享数据","text":"1 使用互斥量保护共享数据互斥量是C++中一种最通用的数据保护机制，但是依旧需要精心组织代码，否则会造成死锁。 1.1 C++中使用互斥量C++中通过实例化std::mutex创建互斥量，通过调用成员函数lock()进行上锁，unlock()进行解锁。在实践中，C++标准库为互斥量提供了一个RAII语法的模板类std::lock_guard，其会在构造的时候提供已锁的互斥量，并在析构的时候进行解锁，从而保证了一个已锁的互斥量总是会被正确的解锁。 但是，当其中一个成员函数返回的是保护数据的指针或引用时，会破坏对数据的保护。具有访问能力的指针或引用可以访问(并可能修改)被保护的数据，而不会被互斥锁限制。互斥量保护的数据需要对接口的设计相当谨慎，要确保互斥量能锁住任何对保护数据的访问，并且不留后门。 1.2 死锁一般解决方案避免死锁的一般建议，就是让两个互斥量总以相同的顺序上锁：总在互斥量B之前锁住互斥量A，就永远不会死锁。某些情况下是可以这样用，因为不同的互斥量用于不同的地方。不过，事情没那么简单，比如：当有多个互斥量保护同一个类的独立实例时，一个操作对同一个类的两个不同实例进行数据的交换操作，为了保证数据交换操作的正确性，就要避免数据被并发修改，并确保每个实例上的互斥量都能锁住自己要保护的区域。不过，选择一个固定的顺序(例如，实例提供的第一互斥量作为第一个参数，提供的第二个互斥量为第二个参数)，可能会适得其反：在参数交换了之后，两个线程试图在相同的两个实例间进行数据交换时，程序又死锁了！ C++标准库有办法解决这个问题，std::lock——可以一次性锁住多个(两个以上)的互斥量，并且没有副作用(死锁风险)。下面的程序清单展示了怎么在一个简单的交换操作中使用std::lock。 123456789101112131415161718192021class X{ private: some_big_object some_detail; std::mutex m; public: void swap(X&amp; lhs, X&amp; rhs){ if(&amp;lhs==&amp;rhs) return; // adopt_lock 要求调用线程当前拥有锁 std::lock(lhs.m, rhs.m); std::lock_guard&lt;std::mutex&gt; lock1(lhs.m, std::adopt_lock); std::lock_guard&lt;std::mutex&gt; lock2(rhs.m, std::adopt_lock); // 等价方法： // std::unique_lock&lt;std::mutex&gt; lock1(lhs.m, std::defer_lock); // std::unique_lock&lt;std::mutex&gt; lock2(rhs.m, std::defer_lock); // std::lock(lock1, lock2); swap(lhs.some_detail,rhs.some_detail); }}; 2 原子类型与原子操作2.1 原子类型与原子操作C++11通过引入原子类型帮助开发者轻松实现原子操作。 123456789101112131415161718192021222324#include &lt;atomic&gt;#include &lt;thread&gt;#include &lt;iostream&gt;using namespace std;atomic_int64_t total = 0; //atomic_int64_t相当于int64_t，但是本身就拥有原子性//线程函数，用于累加void threadFunc(int64_t endNum){ for (int64_t i = 1; i &lt;= endNum; ++i){ total += i; }}int main(){ int64_t endNum = 100; thread t1(threadFunc, endNum); thread t2(threadFunc, endNum); t1.join(); t2.join(); cout &lt;&lt; &quot;total=&quot; &lt;&lt; total &lt;&lt; endl; //10100} 原子类型C++11中通过atomic&lt;T&gt;类模板来定义，比如atomic_int64_t是通过typedef atomic&lt;int64_t&gt; atomic_int64_t实现的，使用时需包含头文件&lt;atomic&gt;。除了提供atomic_int64_t，还提供了其它的原子类型。常见的原子类型有： 原子类型名称 对应内置类型 atomic_bool bool atomic_char atomic_char atomic_char signed char atomic_uchar unsigned char atomic_short short atomic_ushort unsigned short atomic_int int atomic_uint unsigned int atomic_long long atomic_ulong unsigned long atomic_llong long long atomic_ullong unsigned long long atomic_ullong unsigned long long atomic_char16_t char16_t atomic_char32_t char32_t atomic_wchar_t wchar_t 原子操作是平台相关的，原子类型能够实现原子操作是因为C++11对原子类型的操作进行了抽象，定义了统一的接口，并要求编译器产生平台相关的原子操作的具体实现。C++11标准将原子操作定义为atomic模板类的成员函数，包括读（load）、写（store）、交换（exchange）等。对于内置类型而言，主要是通过重载一些全局操作符来完成的。比如对上文total+=i的原子加操作，是通过对operator+=重载来实现的。使用g++编译的话，在x86_64的机器上，operator+=()函数会产生一条特殊的以lock为前缀的x86_64指令，用于控制总线及实现x86_64平台上的原子性加法。 另外，列表中有一个比较特殊的atomic_flag类型，atomic_flag与其他类型不同，它是无锁(lock_free)的，而其他的类型不一定是无锁的。因为，atomic&lt;T&gt;并不能保证类型T是无锁的，另外不同平台的处理器处理方式不同，也不能保证必定无锁，所以其他的类型都会有is_lock_free来判断是否是无锁的。atomic_flag只支持test_and_set以及clear两个成员函数，test_and_set函数检查 std::atomic_flag 标志，如果 std::atomic_flag 之前没有被设置过，则设置 std::atomic_flag 的标志，并返回先前该 std::atomic_flag 对象是否被设置过，如果之前 std::atomic_flag 对象已被设置，则返回 true，否则返回 false；clear函数清除 std::atomic_flag 标志使得下一次调用 std::atomic_flag::test_and_set 返回 false。可以用这两个函数来实现一个自旋锁： 12345678910111213141516171819202122232425262728293031#include &lt;unistd.h&gt;#include &lt;atomic&gt;#include &lt;thread&gt;#include &lt;iostream&gt;std::atomic_flag lock = ATOMIC_FLAG_INIT;void func1(){ while (lock.test_and_set(std::memory_order_acquire)) // 在主线程中设置为true，需要等待t2线程clear { std::cout &lt;&lt; &quot;func1 wait&quot; &lt;&lt; std::endl; } std::cout &lt;&lt; &quot;func1 do something&quot; &lt;&lt; std::endl;}void func2(){ std::cout &lt;&lt; &quot;func2 start&quot; &lt;&lt; std::endl; lock.clear();}int main(){ lock.test_and_set(); // 设置状态 std::thread t1(func1); sleep(1); //睡眠1us std::thread t2(func2); t1.join(); t2.join(); return 0;} 以上代码中，线程t1调用test_and_set一直返回true(因为在主线程中被设置过)，所以一直在等待，而等待一段时间后当线程t2运行并调用了clear，test_and_set返回了false退出循环等待并进行相应操作。这样一来，就实现了一个线程等待另一个线程的效果。当然，可以封装成锁操作的方式，比如： 12void Lock(atomic_flag&amp; lock){ while ( lock.test_and_set()); }void UnLock(atomic_flag&amp; lock){ lock.clear(); } 这样一来，就可以通过Lock()和UnLock()的方式来互斥地访问临界区。 2.2 内存模型、顺序一致性和memory_order内存模型是一个硬件上的概念,表示机器指令是以什么样的顺序被处理器执行的 (现代的处理器不是逐条处理机器指令的) 。C++11中顺序一致性只是多种内存模型中的一种，代码并非必须按照顺序执行，因为顺序往往意味着最低效的同步方式，现代的处理器并不是逐条处理机器指令的。高级语言和机器指令是通过编译器来进行转换的，而编译器处于代码优化的考虑，会将指令进行移动。对于C++11的内存模型而言，要保证代码的顺序一致性，需要同时做到以下几点： 编译器保证原子操作的指令间顺序不变，即产生的读写原子类型变量的机器指令和代码编写顺序是一样的。 处理器对原子操作的汇编指令的执行顺序不变。这对于x86这样的强顺序的体系结构而言没有任何问题，而对于一些弱顺序的平台则需要原子操作之后要加入内存栅栏。 对于一些代码来说，如果只需要在主线程中打印结果，那么代码的执行顺序并不重要。但是atomic原子类型默认的顺序一致性会要求编译器禁用优化，这无疑增加了性能开销。于是C++11中，设计了能够对原子类型指定内存顺序memory_order。 1234567891011// 原始代码void func1(){ a = 1; b = 2;}// 改进代码void func1(){ a.store(1, std::memory_order_relaxed); b.store(2, std::memory_order_relaxed);} 上面的代码使用了store函数进行赋值，store函数接受两个参数，第一个是要写入的值，第二个是名为memory_order的枚举值。这里使用了std::memory_order_relaxed，表示松散内存顺序，该枚举值代表编译器可以任由编译器重新排序或则由处理器乱序处理。这样a和b的赋值执行顺序性就被解除了。在C++11中一共有6种memory_order枚举值，默认按照memory_order_seq_cst执行： 枚举值 定义规则 memory_order_relaxed 不对执行顺序做保证 memory_order_acquire 本线程中,所有后续的读操作必须在本条原子操作完成后执行 memory_order_release 本线程中,所有之前的写操作完成后才能执行本条原子操作 memory_order_acq_rel 同时包含memory_order_acquire和memory_order_release memory_order_consume 本线程中,所有后续的有关本原子类型的操作,必须在本条原子操作完成之后执行 memory_order_seq_cst 全部存取都按顺序执行 需要注意的是，不是所有的memory_order都能被atomic成员使用： store函数可以使用memory_order_seq_cst、memory_order_release、memory_order_relaxed。 load函数可以使用memory_order_seq_cst、memory_order_acquire、memory_order_consume、memory_order_relaxed。 需要同时读写的操作，例如test_and_flag、exchange等操作。可以使用memory_order_seq_cst、memory_order_rel、memory_order_release、memory_order_acquire、memory_order_consume、memory_order_relaxed。 原子类型提供的一些操作符都是memory_order_seq_cst的封装，所以他们都是顺序一致性的。 最后说明一下，std::atomic和std::memory_order只有在多cpu多线程情况下，无锁编程才会用到。在x86下，由于是strong memory order的，所以很多时候只需要考虑编译器优化；保险起见，可以用std::atomic，他会同时处理编译器优化和cpu的memory order（虽然x86用不到）。但是在除非必要的情况下，不用使用std::memory_order，std::atmoic默认用的是最强限制。 2.3 内存栅栏C++中提供了两种栅栏，内存栅栏（atomic_thread_fence）用于解决线程之间表现的内存乱序，其阻止CPU指令层面的乱序优化；编译栅栏（atomic_signal_fence）用于解决与信号处理程序（一种软中断程序）之间表现的内存乱序，其仅阻止编译器层面的乱序优化，不产生内存屏障指令。（内存屏障是一类同步屏障指令，是CPU或者编译器在对内存随机访问的操作中的一个同步点，只有在此点之前的所有读写操作都执行后才可以执行此点之后的操作。） 1234//C++内存栅栏的函数定义：extern &quot;C&quot; void atomic_thread_fence(std::memory_order order) noexcept;//C++编译栅栏的函数定义：extern &quot;C&quot; void atomic_signal_fence(std::memory_order order) noexcept; 参考：C++并发编程(中文版)（C++ Concurrency In Action） C++11原子类型与原子操作 - 腾讯云开发者社区-腾讯云 (tencent.com) (56条消息) 《深入理解C++11》笔记-原子类型和原子操作_WizardtoH的博客-CSDN博客 (56条消息) 处理器协同机制其三C++内存顺序与栅栏（及依赖性读屏障）_c++ 栅栏_一念之卓的博客-CSDN博客","link":"/2023/04/17/%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/"},{"title":"基于锁的并发数据结构(C++)","text":"1 线程安全栈首先看看 std::stack 容器的实现 12345678910111213141516171819template&lt;typename T,typename Container=std::deque&lt;T&gt; &gt;class stack{public: explicit stack(const Container&amp;); explicit stack(Container&amp;&amp; = Container()); template &lt;class Alloc&gt; explicit stack(const Alloc&amp;); template &lt;class Alloc&gt; stack(const Container&amp;, const Alloc&amp;); template &lt;class Alloc&gt; stack(Container&amp;&amp;, const Alloc&amp;); template &lt;class Alloc&gt; stack(stack&amp;&amp;, const Alloc&amp;); bool empty() const; size_t size() const; T&amp; top(); T const&amp; top() const; void push(T const&amp;); void push(T&amp;&amp;); void pop(); void swap(stack&amp;&amp;);}; stack 是以deque 做为底部结构， 将其接口改变，使得其符合先进后出的特点。deque 是双向开口的数据结构，将deque 封闭其头端开口，便形成了stack, 因此便以 deque 作为缺省情况下的stack 底部结构。 在单线程下，上面的stack是安全的，但是在多线程下的情况是如何的呢？ 首先来看下面一段代码： 123456stack&lt;int&gt; s;if (!s.empty()){ // 1 int const value = s.top(); // 2 s.pop(); // 3 do_something(value);} 以上是单线程安全代码：对一个空栈使用top()是未定义行为。对于共享的栈对象，这样的调用顺序就不再安全了，因为在调用empty()①和调用top()②之间，可能有来自另一个线程的pop()调用并删除了最后一个元素。这是一个经典的条件竞争，使用互斥量对栈内部数据进行保护，但依旧不能阻止条件竞争的发生，这就是接口固有的问题。怎么解决呢？问题发生在接口设计上，所以解决的方法也就是改变接口设计。怎么改？在这个简单的例子中，当调用top()时，发现栈已经是空的了，那么就抛出异常。虽然这能直接解决这个问题，但这是一个笨拙的解决方案，这样的话，即使empty()返回false的情况下，你也需要异常捕获机制。本质上，这样的改变会让empty()成为一个多余函数。 仔细观察代码，就会发现另一个潜在的条件竞争在调用top()②和pop()③之间，假设两个线程运行前面的代码。并且都引用同一个对象stacks。假设，一开始栈中只有两个元素，这时任一线程上的empty()和top()都存在竞争，只需要考虑可能的执行顺序即可。当栈被一个内部互斥量所保护时，只有一个线程可以调用栈的成员函数，所以调用可以很好地交错，并且do_something()是可以并发运行的。在下表中，展示一种可能的执行顺序。 Thread A Thread B if (!s.empty); if(!s.empty); int const value = s.top(); int const value = s.top(); s.pop(); do_something(value); s.pop(); do_something(value); 当线程运行时，调用两次top()，栈没被修改，所以每个线程能得到同样的值。不仅是这样，在调用top()函数调用的过程中(两次)，pop()函数都没有被调用。这样，在其中一个值再读取的时候，虽然不会出现“写后读”的情况，但其值已被处理了两次。这种条件竞争，比未定义的empty()/top()竞争更加严重；虽然其结果依赖于do_something()的结果，但因为看起来没有任何错误，就会让这个Bug很难定位。 解决方案：基本思想就是将 top() 和pop() 这两个操作合成一步操作。 另外还有问题，假设有一个stack&lt;vector&lt;int&gt;&gt;，vector是一个动态容器，当你拷贝一个vetcor，标准库会从堆上分配很多内存来完成这次拷贝。当这个系统处在重度负荷，或有严重的资源限制的情况下，这种内存分配就会失败，所以vector的拷贝构造函数可能会抛出一个std::bad_alloc异常。当vector中存有大量元素时，这种情况发生的可能性更大。当pop()函数返回“弹出值”时(也就是从栈中将这个值移除)，会有一个潜在的问题：这个值被返回到调用函数的时候，栈才被改变；但当拷贝数据的时候，调用函数抛出一个异常会怎么样？ 如果事情真的发生了，要弹出的数据将会丢失；它的确从栈上移出了，但是拷贝失败了！std::stack的设计人员将这个操作分为两部分：先获取顶部元素(top())，然后从栈中移除(pop())。这样，在不能安全的将元素拷贝出去的情况下，栈中的这个数据还依旧存在，没有丢失。当问题是堆空间不足，应用可能会释放一些内存，然后再进行尝试。 方案1： 传入一个引用 第一个方案是将变量的引用作为参数，传入pop()函数中获取想要的“弹出值”： 12std::vector&lt;int&gt; result;some_stack.pop(result); 大多数情况下，这种方式还不错，但有明显的缺点：需要构造出一个栈中类型的实例，用于接收目标值。对于一些类型，这样做是不现实的，因为临时构造一个实例，从时间和资源的角度上来看，都是不划算。对于其他的类型，这样也不总能行得通，因为构造函数需要的一些参数，在代码的这个阶段不一定可用。最后，需要可赋值的存储类型，这是一个重大限制：即使支持移动构造，甚至是拷贝构造(从而允许返回一个值)，很多用户自定义类型可能都不支持赋值操作。 方案2：返回指向弹出值的指针 第二个方案是返回一个指向弹出元素的指针，而不是直接返回值。指针的优势是自由拷贝，并且不会产生异常， 缺点就是返回一个指针需要对对象的内存分配进行管理，对于简单数据类型(比如：int)，内存管理的开销要远大于直接返回值。对于选择这个方案的接口，使用std::shared_ptr是个不错的选择；不仅能避免内存泄露(因为当对象中指针销毁时，对象也会被销毁)，而且标准库能够完全控制内存分配方案，也就不需要new和delete操作。这种优化是很重要的：因为堆栈中的每个对象，都需要用new进行独立的内存分配，相较于非线程安全版本，这个方案的开销相当大。 下面给出一个线程安全的stack，它实现了方案1和方案2：重载了pop()，使用一个局部引用去存储弹出值，并返回一个std::shared_ptr&lt;&gt;对象。它有一个简单的接口，只有两个函数：push()和pop()。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;exception&gt;#include &lt;mutex&gt;#include &lt;memory&gt;struct empty_stack: std::exception{ const char* what() const throw();};template&lt;typename T&gt;class threadsafe_stack{ private: std::stack&lt;T&gt; st; mutable std::mutex m; public: threadsafe_stack(){} threadsafe_stack(const threadsafe_stack&amp; other){ std::lock_guard&lt;std::mutex&gt; lock(other.m); st = other.st; } threadsafe_stack&amp; operator=(const threadsafe_stack&amp;) = delete; void push(T new_value){ std::lock_guard&lt;std::mutex&gt; lock(m); st.push(std::move(new_value)); } std::shared_ptr&lt;T&gt; pop(){ std::lock_guard&lt;std::mutex&gt; lock(m); if (st.empty()) throw empty_stack(); std::shared_ptr&lt;T&gt; const res(std::make_shared&lt;T&gt;(std::move(st.top()))); st.pop(); return res; } void pop(T&amp; value){ std::lock_guard&lt;std::mutex&gt; lock(m); if (st.empty()) throw empty_stack(); value = std::move(st.top()); st.pop(); } bool empty() const{ std::lock_guard&lt;std::mutex&gt; lock(m); return st.empty(); }} 2 线程安全队列std::queue&lt;&gt; 容器的接口展示如下： 123456789101112131415161718192021template &lt;class T, class Container = std::deque&lt;T&gt; &gt;class queue {public: explicit queue(const Container&amp;); explicit queue(Container&amp;&amp; = Container()); template &lt;class Alloc&gt; explicit queue(const Alloc&amp;); template &lt;class Alloc&gt; queue(const Container&amp;, const Alloc&amp;); template &lt;class Alloc&gt; queue(Container&amp;&amp;, const Alloc&amp;); template &lt;class Alloc&gt; queue(queue&amp;&amp;, const Alloc&amp;); void swap(queue&amp; q); bool empty() const; size_type size() const; T&amp; front(); const T&amp; front() const; T&amp; back(); const T&amp; back() const; void push(const T&amp; x); void push(T&amp;&amp; x); void pop(); template &lt;class... Args&gt; void emplace(Args&amp;&amp;... args);}; 当你忽略构造、赋值以及交换操作时，你就剩下了三组操作： 对整个队列的状态进行查询(empty()和size()) 查询在队列中的各个元素(front()和back()) 修改队列的操作(push(), pop()和emplace()) 因此你也会遇到在固有接口上的条件竞争。你需要将front()和pop()合并成一个函数调用，就像之前在栈实现时合并top()和pop()一样。 不同的是：当使用队列在多个线程中传递数据时，接收线程通常需要等待数据的压入。这里我们提供pop()函数的两个变种：try_pop()和wait_and_pop()。try_pop() ，尝试从队列中弹出数据，总会直接返回(当有失败时)，即使没有值可检索；wait_and_pop()，将会等待有值可检索的时候才返回。当你使用之前栈的方式来实现你的队列，你实现的队列就可能会是下面这样： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;queue&gt;#include &lt;memory&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;template&lt;typename T&gt;class threadsafe_queue{ private: mutable std::mutex m; // 1 互斥量必须是可变的 std::queue&lt;T&gt; que; std::condition_variable data_cond; public: threadsafe_queue(){} threadsafe_queue(threadsafe_queue const&amp; other){ std::lock_guard&lt;std::mutex&gt; lock(other.m); que = other.que; } void push(T new_value){ std::lock_guard&lt;std::mutex&gt; lock(m); que.push(new_value); data_cond.notify_one(); } void wait_and_pop(T&amp; value){ std::unique_lock&lt;std::mutex&gt; lock(m); data_cond.wait(lock,[this]{return !que.empty();}); value = que.front(); que.pop(); } std::shared_ptr&lt;T&gt; wait_and_pop(){ std::unique_lock&lt;std::mutex&gt; lock(m); data_cond.wait(lock,[this]{return !que.empty();}); std::shared_ptr&lt;T&gt; res(std::make_shared&lt;T&gt;(que.front())); que.pop(); return res; } bool try_pop(T&amp; value){ std::lock_guard&lt;std::mutex&gt; lock(m); if(que.empty()) return false; value=que.front(); que.pop(); return true; } std::shared_ptr&lt;T&gt; try_pop(){ std::lock_guard&lt;std::mutex&gt; lock(m); if(que.empty()) return std::shared_ptr&lt;T&gt;(); std::shared_ptr&lt;T&gt; res(std::make_shared&lt;T&gt;(que.front())); que.pop(); return res; } bool empty() const{ std::lock_guard&lt;std::mutex&gt; lock(m); return que.empty(); }}; 第3章 线程间共享数据 - 3.2 使用互斥量保护共享数据 - 《C++并发编程(中文版)（C++ Concurrency In Action）》 - 书栈网 · BookStack (56条消息) 多线程编程– 线程安全的栈 stack_deanlan_sjtu的博客-CSDN博客","link":"/2023/04/18/%E5%9F%BA%E4%BA%8E%E9%94%81%E7%9A%84%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C/"},{"title":"无锁数据结构-栈(C++)","text":"1 无锁数据结构的优点和缺点优点: 最大限度实现并发：在基于锁的容器上，若某个线程还未完成操作，就大有可能阻塞另一线程，使之陷入等待而无法处理；而且，互斥锁的根本意图是杜绝并发功能。在无锁数据结构上，总是存在某个线程能执行下一操作。 代码的健壮性：假设数据结构的写操作受锁保护，如果线程在持锁期间终止，那么该数据结构只完成了部分改动，且此后无从修补。但是（无锁数据结构），若某线程操作无锁数据时意外终结，则丢失的数据仅限于它持有的部分，其他数据依然完好，能被别的线程正常处理。无锁数据结构不含锁，因此不会出现死锁。 缺点： 难度大：对线程安全的无锁数据结构执行写操作，难度远远高于对带锁的数据结构体执行写操作。需留心施加在各项操作上的内存次序约束。 活锁：由于无锁数据结构完全不含锁，因此不可能出现死锁，但活锁反而有机会出现。假设两个线程同时修改同一份数据结构，若他们所做的改动都导致对方从头开始操作，那双方就会反复循环，不断重试，这种现象即为活锁。活锁出现与否完全取决于线程的调度次序，故往往只会短暂存在。因此，它们虽然降低了程序性能，尚不至于造成严重的问题，但我们仍需小心防范。 降低整体性能：即便没有其他线程同时访问数据机头，也依然要执行更多步骤。所以，虽然它提高了操作同一个数据结构的并发程度，缩短了单个线程因等待而消耗的时间，却有可能降低整体性能。首先对比原子操作，无锁代码所采用的原子操作要缓慢很多。对于基于锁的数据结构，其原子操作仅涉及互斥的加锁行为，相比之下，无锁数据结构种原子操作的数据可能更多。 2 无锁栈2.1 简介 栈容器能加入数据，然后按逆序取出——先进后出（后进先出——last in,fist out,LIFO). 因此，我们必须保证，一旦某线程将一项数据加入栈容器，就能立即安全的被另一个线程取出，同时还得保证，只有唯一一个线程能获取该项数据。 最简单的栈容器可以通过链表的形式实现：指针head指向第一个节点，各节点内的next成员指针再依次指向后继节点。 2.2 无锁栈原理图 2.3 添加节点（push）步骤1：创建新节点。步骤2：令新节点的成员指针next指向当前的头节点。步骤3：把head指针指向新节点。 但是这里有个问题，当有两个线程同时添加节点的时候，在第2步和第3步的时候会产生条件竞争：一个线程可能在修改head的值时，另一个线程正在执行第2步，并且在第3步中对head进行更新。这就会使之前那个线程的工作被丢弃，亦或是造成更加糟糕的后果。在了解如何解决这个条件竞争之前，还要注意一个很重要的事：当head更新，并指向了新节点时，另一个线程就能读取到这个节点了。因此，在head设置为指向新节点前，让新节点完全准备就绪就变得很重要了；因为，在这之后就不能对节点进行修改了。 那如何应对讨厌的条件竞争呢？答案就是：在第3步的时候使用一个原子“比较/交换”操作，来保证当步骤2对head进行读取时，不会对head进行修改。当有修改时，可以循环“比较/交换”操作。下面的代码就展示了，不用锁来实现线程安全的push()函数。 1234567891011121314151617181920template&lt;typename T&gt;class lock_free_stack{ private: struct node{ T value; node* next; node(T const&amp; data_) :value(data_), next(nullptr) {} }; std::atomic&lt;node*&gt; m_head; public: lock_free_stack(){ m_head.store(nullptr); }; void push(T const&amp; data){ node* const new_node = new node(data); new_node-&gt;next = m_head.load(); while (!m_head.compare_exchange_weak(new_node-&gt;next, new_node)); }}; 我们可以注意到一个非常巧妙的设计。在push方法里，atomic_compare_exchange_weak如果失败，证明有其他线程更新了栈顶，而这个时候被其他线程更新的新栈顶值会被更新到new_node-&gt;next中，因此循环可以直接再次尝试压栈而无需由程序员更新new_node-&gt;next。 2.4 弹出数据（pop）步骤1：读取当前head指针的值。 步骤2：读取head-&gt;next。 步骤3：设置head到head-&gt;next。 步骤4：通过索引node，返回data数据。 步骤5：删除索引节点。 3 没提过的基础知识——关于atomic &lt;T&gt;C++11给我们带来的Atomic一系列原子操作类，它们提供的方法能保证具有原子性。这些方法是不可再分的，获取这些变量的值时，永远获得修改前的值或修改后的值，不会获得修改过程中的中间数值。这些类都禁用了拷贝构造函数，原因是原子读和原子写是2个独立原子操作，无法保证2个独立的操作加在一起仍然保证原子性。 atomic&lt;T&gt;提供了常见且容易理解的方法： store：原子写操作 load：原子读操作 exchange：允许2个数值进行交换，并保证整个过程是原子的 compare_exchange_strong：即CAS，入参是3个，expect，desire，memoryorder，意思是如果当前的变量this的值==expect值，则将this值改为desire，并返回true，否则，将expect修改为this，返回false。 compare_exchange_weak：即CAS，和strong类似，但是这个函数可能在满足true的情况下仍然返回false，所以只能在循环里使用，否则可以使用它的strong版本。而这个weak版本考虑到了硬件性能的最优化，在使用CAS时一般都只会用到它。 参考： (56条消息) C++11 CAS无锁函数compare_exchange_weak的使用_chansoncc的博客-CSDN博客 (56条消息) C++11：原子交换函数compare_exchange_weak和compare_exchange_strong_原子变量exchange_吃素的施子的博客-CSDN博客 第7章 无锁并发数据结构设计 - 7.2 无锁数据结构的例子 - 《C++并发编程(中文版)（C++ Concurrency In Action）》 - 书栈网 · BookStack (56条消息) 【并发编程十五】无锁数据结构（1）——无锁栈_郑同学的笔记的博客-CSDN博客","link":"/2023/04/18/%E6%97%A0%E9%94%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88-C/"}],"tags":[{"name":"gdb","slug":"gdb","link":"/tags/gdb/"},{"name":"C++ Tools","slug":"C-Tools","link":"/tags/C-Tools/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"事务","slug":"事务","link":"/tags/%E4%BA%8B%E5%8A%A1/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"https","slug":"https","link":"/tags/https/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"多线程","slug":"多线程","link":"/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"并发","slug":"并发","link":"/tags/%E5%B9%B6%E5%8F%91/"},{"name":"栈","slug":"栈","link":"/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","link":"/tags/%E9%98%9F%E5%88%97/"},{"name":"锁","slug":"锁","link":"/tags/%E9%94%81/"},{"name":"原子操作","slug":"原子操作","link":"/tags/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/"}],"categories":[{"name":"C++ Tools","slug":"C-Tools","link":"/categories/C-Tools/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"杂项","slug":"杂项","link":"/categories/%E6%9D%82%E9%A1%B9/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"计算机网络","slug":"计算机网络","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"并发编程","slug":"并发编程","link":"/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"pages":[{"title":"categories","text":"","link":"/categories/index.html"}]}